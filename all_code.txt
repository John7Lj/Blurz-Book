
### server/run.bat
server commands
//create virtual environment::

Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
.venv\Scripts\Activate.ps1

//run server::

uvicorn main:app --host 0.0.0.0 --port 8000 --reload

// run celery::

celery -A src.celery.celery_tasks worker --loglevel=info --pool=solo


// about redis::
you have to only to download redis server from  this link https://release-assets.githubusercontent.com/github-production-release-asset/3402186/124bda0a-3fa5-11e6-8c4a-803581ed704c?sp=r&sv=2018-11-09&sr=b&spr=https&se=2026-01-30T21%3A17%3A00Z&rscd=attachment%3B+filename%3DRedis-x64-3.0.504.msi&rsct=application%2Foctet-stream&skoid=96c2d410-5711-43a1-aedd-ab1947aa7ab0&sktid=398a6654-997b-47e9-b12b-9515b896b4de&skt=2026-01-30T20%3A16%3A23Z&ske=2026-01-30T21%3A17%3A00Z&sks=b&skv=2018-11-09&sig=3LgycGD1xr%2BSYYEtvevT6q%2Bw6C7exVjLMv8%2FIuk0IYY%3D&jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmVsZWFzZS1hc3NldHMuZ2l0aHVidXNlcmNvbnRlbnQuY29tIiwia2V5Ijoia2V5MSIsImV4cCI6MTc2OTgwNTg3NCwibmJmIjoxNzY5ODA1NTc0LCJwYXRoIjoicmVsZWFzZWFzc2V0cHJvZHVjdGlvbi5ibG9iLmNvcmUud2luZG93cy5uZXQifQ.xESA9Av1yODr6u7ALjBwrZPz1ENJdpsJGW4aNF9q__U&response-content-disposition=attachment%3B%20filename%3DRedis-x64-3.0.504.msi&response-content-type=application%2Foctet-stream
and install it on your system then run it but through the installation make sure its port is 6379 

//run migrations::
alembic revision --autogenerate -m "add ur comments here "
alembic upgrade head
















project i have to make :

1- 
chat app like watsapp 

2-
streaming app like twitch 

3-
blockchain app 

4-
simple ecommerce app

5-
simple social media app

6-
simple blog app

7-
simple ai model app



### server/main.py
from fastapi import FastAPI  ,status
from src.book.routes import book_router
from src.mailserver.routes import mail_router
from  fastapi.requests import Request
from src.auth.routes import auth_router
from contextlib import asynccontextmanager
from src.db.main import init_db
from src.reviews.routes import review_router
from src.errors import register_error_handlers
from src.err import creation_exceptions
from fastapi.responses import JSONResponse
from src.middleware import custome_simple_middle
from src.db.redis import check_redis_connection

@asynccontextmanager # this IS A dicorator act like class function that excute a fuctions before that happen and ecxute a function after an evernt
async def life_span(app:FastAPI):
#here the instructions that be run first when the server run

 print("the server has been started")
 # this is a async
 await init_db()
 await check_redis_connection()

 yield #this word seperate that when the server start before it will run first ,
 #after it run when the server will be stoppped the instruction excute
 print("the server has been stopped")

version = "v1"

app = FastAPI(version=version,title="Blurz Book service",
              description="a high performance book web service",
              lifespan=life_span,
              redoc_url=f"/api/{version}/redocs",
              docs_url=f"/api/{version}/docs",
              contact={"email":"ffkiuyh@gmail.com"},
                          
 ) 



"""this is exceptions registers """
creation_exceptions(app)
custome_simple_middle(app)


async def internal_server_error(e:Exception,r:Request):

            return JSONResponse(
                content={
                    
                    "message": "Oops! Something went wrong",
                    "error_code": "server_error",
                    'status_code':status.HTTP_500_INTERNAL_SERVER_ERROR,

                },
            )



app.add_exception_handler(500,internal_server_error)


app.include_router(book_router, prefix=f"/api/{version}/book",tags="book") 
app.include_router(auth_router, prefix=f"/api/{version}/auth",tags="auth") 
app.include_router(review_router, prefix=f"/api/{version}/reviews",tags="reviews") 
app.include_router(mail_router, prefix=f"/api/{version}/emails",tags="emails") 


"""Experimental endpoint to check the overriding of the exception will happen or not """

async def crash_by_division_zero ():
    return 4/0

app.add_api_route(path='/crash',
                 endpoint =  crash_by_division_zero,
                  methods=['GET']
                       )

### server/requirements.txt
pydantic
fastapi
uvicorn
fastapi-mail
jinja2
sqlmodel
sqlalchemy
pyjwt
bcrypt

alembic
redis

celery
asgiref
pydantic-settings

flower

pytest
pytest-asyncio
pytest-cov 
httpx
python-multipart
python-dotenv
itsdangerous


### server/alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the tzdata library which can be installed by adding
# `alembic[tz]` to the pip requirements.
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os


# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.


sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# hooks = ruff
# ruff.type = module
# ruff.module = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Alternatively, use the exec runner to execute a binary found on your PATH
# hooks = ruff
# ruff.type = exec
# ruff.executable = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

### server/src/db/config.py
from pydantic_settings import BaseSettings,SettingsConfigDict


class settings(BaseSettings):
    DB_URL : str 
    BCRYPT_ROUNDS :int= 14
    jwt_secret:str
    jwt_algorithm:str
    refresh_token_expiary:int
    access_token_expiary:int
#   ResisHost :str
#    ResdisPort :int
#    Redispassword :str
#    Redis_DB :int
    Redis_Url:str
    MAIL_USERNAME:str
    MAIL_PASSWORD:str
    MAIL_FROM:str
    MAIL_PORT:int
    MAIL_SERVER:str
    MAIL_FROM_NAME:str
    MAIL_STARTTLS: bool = True
    MAIL_SSL_TLS: bool = False
    USE_CREDENTIALS: bool = True
    VALIDATE_CERTS: bool = True
    domain:str
    password_secrete_reset:str
    model_config = SettingsConfigDict (env_file=".env",  extra="ignore")


config = settings()



# Celery configuration
broker_url = config.Redis_Url
result_backend = config.Redis_Url
broker_connection_retry_on_startup = True

### server/src/db/main.py
from sqlmodel import SQLModel
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from sqlmodel.ext.asyncio.session import AsyncSession
from .config import config

# Create async engine
engine = create_async_engine(
    config.DB_URL,
    echo=True,  # Optional: log SQL statements
    future=True
)

# Initialize database tables
async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)

async_session = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False
)

# Dependency for getting sessions
async def get_session():
    async with async_session() as session:
        yield session

### server/src/db/models.py
from sqlmodel import SQLModel, Field, Column, Relationship
from sqlalchemy import func
import uuid
from datetime import datetime
import sqlalchemy.dialects.postgresql as pg
from typing import List, Optional


class User(SQLModel, table=True):
    __tablename__ = "User" 
    
    id: uuid.UUID = Field(
        primary_key=True,
        nullable=False,
        default_factory=uuid.uuid4
    )
    username: str
    email: str
    first_name: str = Field(default="new_user") 
    last_name: str = Field(default="new_user")  
    role: str = Field(
        sa_column=Column(
            pg.VARCHAR,
            nullable=False,
            server_default="user"
        )
    )
    
    books: List["Book"] = Relationship(
        back_populates="user",
        sa_relationship_kwargs={
            "lazy": "selectin", 
            "cascade": "all, delete-orphan"
        }
    )
    
    reviews: List["Review"] = Relationship(
        back_populates="user",
        sa_relationship_kwargs={
            "lazy": "selectin", 
            "cascade": "all, delete-orphan"
        }
    )
       
    password_hash: str = Field(exclude=True)
    is_verifed: bool = Field(default=False)
    
    created_at: datetime = Field(
        sa_column=Column(
            pg.TIMESTAMP,
            server_default=func.now(),
            nullable=False
        )
    )
    
    updated_at: datetime = Field(
        sa_column=Column(
            pg.TIMESTAMP,
            server_default=func.now(),
            onupdate=func.now(),
            nullable=False
        )
    )
    
    def __repr__(self):
        return f"User(username={self.username})"


class Book(SQLModel, table=True):
    __tablename__ = "Book"

    id: uuid.UUID = Field(
        primary_key=True,
        nullable=False,
        default_factory=uuid.uuid4
    )
    
    user_id: uuid.UUID | None = Field(default=None, foreign_key="User.id")
    title: str = Field(nullable=False)
    author: str | None = None
    description: str
    page_count: int | None = None
    category: str
    
    user: Optional['User'] = Relationship(back_populates="books")
    
    reviews: List["Review"] = Relationship(
        back_populates="book",
        sa_relationship_kwargs={'lazy': 'selectin'}
    )



    file_path: str | None = None  # Path to the PDF/epub file
    file_size: int | None = None  # Size in bytes
    file_type: str | None = None  # "pdf", "epub", "mobi", etc.
    
    publisher: str | None = None
    published_date: datetime | None = Field(default_factory=datetime.now)
    language: str | None = None
    
    created_at: datetime = Field(
        sa_column=Column(
            pg.TIMESTAMP,
            server_default=func.now(),
            nullable=False
        )
    )
    
    updated_at: datetime = Field(
        sa_column=Column(
            pg.TIMESTAMP,
            server_default=func.now(),
            onupdate=func.now(),
            nullable=False
        )
    )
    
    def __repr__(self):
        return f"Book(title={self.title})"


class Review(SQLModel, table=True):
    __tablename__ = "Review"

    id: uuid.UUID = Field(
        primary_key=True,
        nullable=False,
        default_factory=uuid.uuid4
    )
    
    rating: int = Field(le=5)
    comment: str = Field(max_length=80)
    user_id: uuid.UUID | None = Field(default=None, foreign_key="User.id")
    book_id: uuid.UUID | None = Field(default=None, foreign_key="Book.id")
    
    created_at: datetime = Field(
        sa_column=Column(
            pg.TIMESTAMP,
            server_default=func.now(),
            nullable=False
        )
    )
    
    updated_at: datetime = Field(
        sa_column=Column(
            pg.TIMESTAMP,
            server_default=func.now(),
            onupdate=func.now(),
            nullable=False
        )
    )
    
    user: Optional['User'] = Relationship(back_populates="reviews")
    book:['Book'] = Relationship(back_populates="reviews")
    
    def __repr__(self):
        return f"This review {self.book_id} is made by this user:{self.user_id}"

### server/src/db/redis.py
from redis.asyncio import Redis
from redis.exceptions import ConnectionError
from .config import config

# Create Redis client
Token_Blacklist = Redis.from_url(config.Redis_Url, decode_responses=True)

# Async function to check Redis connection
async def check_redis_connection():
    try:
        await Token_Blacklist.ping()
        print('âœ“ Redis is working')
        return True
    except ConnectionError as e:
        print(f'âœ— Redis is not working: {e}')
        return False

# Add to blacklist with error handling
async def add_to_blacklist(jti: str, exp=1800):
    try:
        result = await Token_Blacklist.set(name=jti, value='', ex=exp)
        if result:
            print(f'âœ“ Token blacklisted: {jti}')
        return result
    except ConnectionError as e:
        print(f'âœ— Redis error in add_to_blacklist: {e}')
        return False

# Check blacklist with error handling
async def check_blacklist(jti: str) -> bool:
    try:
        result = await Token_Blacklist.get(name=jti)
        return result is not None
    except ConnectionError as e:
        print(f'âœ— Redis error in check_blacklist: {e}')
        # Return False to allow access when Redis is down (or True to deny)
        return False

### server/src/auth/dependencies.py
   
        
from fastapi.security import HTTPBearer
from fastapi import status,Request,Depends
from fastapi.exceptions import HTTPException
from .utils import decode_token
from src.db.redis import check_blacklist
from sqlmodel.ext.asyncio.session import AsyncSession
from src.db.main import get_session
from .service import User_Service
import logging
from src.db.models import User
from src.err import (
    InvalidToken,
    RefreshTokenRequired,
    AccessTokenRequired,
    InsufficientPermission,
    VerificationError,
    EmailNotVerified
)
class BearerToken(HTTPBearer):
    
    def __init__(self,auto_error:bool=True):
        super().__init__(auto_error=auto_error)
        
        
    async def __call__(self,request:Request):
        credits = await super().__call__(request)
        
        token_data = decode_token(credits.credentials)
    
        if not token_data :
            raise InvalidToken()
            
        if await check_blacklist(token_data['jti']):
            raise HTTPException(
                status_code = status.HTTP_403_FORBIDDEN,
                                detail = 'This token has been revoked , plz get a valid token')
            
        self.verify_token(token_data)
        
        return token_data # here if all exceptions false then the token will be valid and will return it to the user 
    
    def verify_token(self,token:dict):
        
         print('this must be override in the access and refresh class to sure its access or refresh token')
          
     
   
class AccessTokenBearer(BearerToken):
    
    def verify_token (self,token:dict):
            
        if (token and token['refresh_token']):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                                detail = 'plz provide Acess token not Refresh ')
            
            
            
class RefreshToken(BearerToken):
    
    def verify_token (self,token:dict):
        if token and not token['refresh_token']:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                                detail = 'plz provide Refresh token not access ')




async def get_current_user(token: dict = Depends(AccessTokenBearer()),
                           session: AsyncSession = Depends(get_session)) -> object:
    
    email = token['user']['email']
    try:
        user = await User_Service().get_user_by_email(email, session)
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        return user
        
    except HTTPException:
        raise  # Re-raise HTTP exceptions
        
    except Exception as e:
        logging.exception(f'Error fetching user: {e}')
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to fetch user"
        )
 
class CheckRoler :
    def __init__ (self,allowd_rloes:list[str]):
        self.allowd_rloes = allowd_rloes
        
    def __call__(self,user_details:User=Depends(get_current_user))->bool:
        
        if not user_details.is_verifed:
            raise EmailNotVerified()
        
        if user_details:
            if user_details.role in self.allowd_rloes:
                return True
            raise InsufficientPermission()
        

### server/src/auth/routes.py
from fastapi import APIRouter, Depends, status, HTTPException
from src.db.main import get_session
from .service import User_Service
from .schema import Create_User as Create_User_Model, User,Login_User,UserInfo,Password_Reset,Password_reset_Confirm
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlalchemy.exc import IntegrityError
from .utils import access_token,verify_password,CreationSafeLink,generate_hashed_password
from datetime import datetime,timedelta
from src.db.config import config
from fastapi.responses import JSONResponse
from .dependencies import RefreshToken,AccessTokenBearer,get_current_user,CheckRoler
from src.err import AccessTokenRequired,UserAlreadyExists,UserNotFound,InvalidCredentials,VerificationError,DataNotFound,PasswordAlreadyReset,UserAlreadyVerify
from src.db.redis import add_to_blacklist,check_blacklist
from src.mailserver.service import send_email,mail
from src.celery.celery_tasks import bg_send_mail
from src.db.models import User as User_DB


auth_router = APIRouter()

user_service = User_Service()
checkroler = Depends(CheckRoler(['admin','user']))

access_token_bearer = AccessTokenBearer()

password_reset_link = CreationSafeLink(config.password_secrete_reset,'password_reset_link')

email_verification_link = CreationSafeLink(config.jwt_secret,'email_verification_link')


refresh = timedelta(days=config.refresh_token_expiary)

access = timedelta(minutes=config.access_token_expiary)

@auth_router.post("/signup",
                  response_model=User,
                  status_code=status.HTTP_201_CREATED,
                  )
async def create_user(
    user_data: Create_User_Model
    , 
    session: AsyncSession = Depends(get_session)
                   ):

    email = user_data.email
    is_existed = await user_service.user_exist(email, session)
    
    if is_existed:
        raise UserAlreadyExists()
    
    try:
        
        new_user = await user_service.create_user(user_data, session)
        token = email_verification_link.create_safe_url({"email":email})
      
        link = f'{config.domain}/auth/verify/{token}'
        
        data = {"link":link}
        
        bg_send_mail.delay(rec=[email], sub='verify email', html_path='verify_message.html', data_var=data) # the result is a message that sent to the user wiht link
      
      
        return new_user
    except IntegrityError:
        raise UserAlreadyExists()




"""verify the URL to check is valid"""  
@auth_router.get("/verify/{token}")

async def activation_user(token:str,session:AsyncSession=Depends(get_session)):
    
    data = email_verification_link.de_serializ_url(token)
    
    if await check_blacklist(data['token_id']):
        raise UserAlreadyVerify()
    
    email = data['email']
    if not email:
        raise VerificationError()
    
    await user_service.activation_user(email,session)
    
    await add_to_blacklist(data['token_id'],exp=1600)

    return JSONResponse(
            content={"message": "Account verified successfully"},
            status_code=status.HTTP_200_OK,
        )    



@auth_router.post('/resend_verify_link')
async def crtate_url_vreification(email:Password_Reset,session: AsyncSession = Depends(get_session)):
    email = email.email
    if not email :
        raise DataNotFound()
    is_existed = await user_service.user_exist(email, session)
    
    if is_existed:
    
        token = email_verification_link.create_safe_url({"email":email})
      
        link = f'{config.domain}/auth/verify/{token}'
        
        data = {"link":link}
        
        bg_send_mail.delay(rec=[email],sub = 'verifying mail',html_path='verify_message.html',data_var=data)
        




@auth_router.post('/login',)
async def login_user(user_data:Login_User,session:AsyncSession=Depends(get_session)):
    user_data_login = user_data
    email = user_data_login.email
    password = user_data_login.password
    
    # ADD THESE DEBUG LOGS
    print(f"ðŸ” LOGIN ATTEMPT:")
    print(f"   Email received: {email}")
    print(f"   Email type: {type(email)}")
    print(f"   Email length: {len(email)}")
    print(f"   Email stripped: '{email.strip()}'")
    
    # check if the user exist or not 
    user_existence:User_DB = await user_service.get_user_by_email(email, session)
    
    print(f"   User found: {user_existence is not None}")
    if user_existence:
        print(f"   Found user: {user_existence.email}")
    
    if not user_existence:
        raise UserNotFound()
      
    is_valid_password = verify_password(password, user_existence.password_hash) 
     
    if is_valid_password:
        
        # Create tokens
        access_token_str = access_token(
            user_data={
                "email": email,
                "id": str(user_existence.id),
                "username": user_existence.username,
            },
            expire=access
        )
        
        refresh_token_str = access_token(
            user_data={
                "email": email,
                "id": str(user_existence.id),
                "username": user_existence.username,
            },
            expire=refresh,
            refresh=True
        )  
        
        return JSONResponse(
            content={
                "message": "you have login successfully",
                "access_token": access_token_str,
                "refresh_token": refresh_token_str,
                "email": email,
                "username": user_existence.username,
                "user_id": str(user_existence.id)
            },
            status_code=200
        )
    else:
        raise InvalidCredentials()

@auth_router.get('/me',response_model=UserInfo,
                    dependencies=[checkroler])

async def get_me(user_details:User=Depends(get_current_user)):
    return user_details

    
@auth_router.post('/refresh_token')
async def get_acces_by_refresh(token:dict=Depends(RefreshToken())):
    
    if token:
        new_access_token = access_token(user_data=token['user'],expire=access)
        
        return JSONResponse(
               content ={
                  "access_token":new_access_token
             } )
    
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
                        detail='this token either expired or invalid')
     
    
@auth_router.post('/logout')
async def logout(token:dict=Depends(AccessTokenBearer())):
    
    if await add_to_blacklist(token['jti']):
        return JSONResponse(
            content={"Message":"you have loged out successflly"},
            status_code = 200,

        )
    else:
        print('there was an erro while revoking this token ')
    
    
    
    """
    
    notice this for forget Password reset flow , not regular reset password this in case the user forget the original password
    
    1: user request to resent his password 
    
    2: the token or the email exctracted from but be carfull , we check if exist or not then if exist 

    3: we shall send to this user mail an uniuque link that contain a token with period expiration and this email
        
    4: when the user click on this link and the link is valid the user can now reset the password and revoke the token of authorization 
    and add to the redis black list
    
    
    5: after the user has successfully updated the password the access ,refresh and link token must be revoked and added to the redis blacklist
    
    """ 
   # Notice this is for forgetting password and not in normal reset password 
@auth_router.post('/password_reset')
async def passsword_reset(Email:Password_Reset,session:AsyncSession=Depends(get_session),_=Depends(AccessTokenBearer())):
    email = Email.email
    
    user_existence = await user_service.get_user_by_email(email,session)
    
    if not user_existence:
        raise UserNotFound()
    
    try:
        
        token = password_reset_link.create_safe_url({"email":email})
      
        link = f'{config.domain}/auth/confirm_password/{token}'
        
        data = {"link":link}
        
        bg_send_mail.delay(rec=email,
                            data_var=data,html_path='password_reset_link.html',
                            sub = 'Reset Email Password')# the result is a message that sent to mail user wiht link
      
      
    except IntegrityError:
        raise UserAlreadyExists() 
    
@auth_router.post("/confirm_password/{token}")

async def confirm_password(passwords:Password_reset_Confirm
                           ,token:str,session:AsyncSession=Depends(get_session)
                           ,access_token:dict=Depends(AccessTokenBearer()),):
    
    data = password_reset_link.de_serializ_url(token,600)
    
    """check if this link is beeing sent again to prevent it from consuming resourse """
    if await check_blacklist(data['token_id']):
        raise UserAlreadyVerify()
    

    if not passwords.new_password==passwords.confirm_password:
        raise InvalidCredentials()
    
    email = data['email']
    if not email:
        raise DataNotFound()
    try:
        user_exist =  await user_service.get_user_by_email(email,session)
        if not user_exist:
            raise UserNotFound()
    except IntegrityError:
        raise IntegrityError()
    new_password = generate_hashed_password(passwords.new_password)
    user_exist.password_hash = new_password
    await session.commit()
    await session.refresh(user_exist)
    
    """if the user arrive hr this mean the user has successfully verify so we should block this ulr beeing used again"""
    
    await add_to_blacklist(access_token['jti'])
    await add_to_blacklist(data['token_id'],exp=600)
   
    
    return JSONResponse(
            content={"message": "Password has been updated successfully"},
            status_code=status.HTTP_200_OK,
        )  

### server/src/auth/schema.py
from pydantic import BaseModel, Field
import uuid
from datetime import datetime
from typing import  List
from src.book.schema import Book
from src.reviews.schema import Review
class User(BaseModel): 
    id: uuid.UUID 
    username: str = Field(max_length=20)
    email: str = Field(max_length=40)
    first_name: str
    last_name: str
    is_verifed: bool 
    created_at: datetime | None = None  # âœ… Made optional
    updated_at: datetime | None = None  # âœ… Made optional




class UserInfo(User):
    books:List[Book]
    reviews:List[Review]

""""password mustn't given at the reponse model"""


class Create_User(BaseModel): 
    username: str = Field(max_length=20)
    email: str = Field(max_length=40)
    first_name: str
    last_name: str
    password: str = Field(min_length=8, max_length=72) 
    

class Update_User(BaseModel): 
    username: str = Field(max_length=20)
    first_name: str
    last_name: str
    is_verifed: bool 
    
    
class User_Activation(BaseModel): 
    is_verifed: bool 



    
class Login_User(BaseModel): 
    email: str = Field(max_length=40)
    password: str = Field(min_length=8, max_length=72) 
    
    
    
class Password_Reset(BaseModel):
    email:str
    
    
class Password_reset_Confirm(BaseModel):
    new_password:str=Field(min_length=8, max_length=72) 
    confirm_password:str=Field(min_length=8, max_length=72) 

### server/src/auth/service.py
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlmodel import select
from src.db.models import User as User_Model
from .schema import Create_User,Update_User
from .utils import generate_hashed_password
from src.err import UserAlreadyExists,UserAlreadyVerify,UserNotFound

import logging
class User_Service:

    # In your User_Service class, update get_user_by_email method:

    async def get_user_by_email(self, email: str, session: AsyncSession):
        # ADD DEBUG LOGS
        print(f"ðŸ”Ž SEARCHING FOR USER:")
        print(f"   Looking for email: '{email}'")
        print(f"   Email stripped: '{email.strip()}'")
        
        # Try with stripped email
        email = email.strip().lower()  # Strip whitespace and lowercase
        print(f"   Normalized email: '{email}'")
        
        statement = select(User_Model).where(User_Model.email == email)
        result = await session.execute(statement)
        user = result.scalar_one_or_none()
        
        print(f"   User found: {user is not None}")
        if user:
            print(f"   Found: {user.email}")
        
        return user


    async def user_exist(self, email: str, session: AsyncSession):
        user = await self.get_user_by_email(email, session)
        return bool(user)
    
  
    async def create_user(self, user_data: Create_User, session: AsyncSession):
        user_data_in_dict = user_data.model_dump()
        
        # Swap 'password' for 'password_hash'
        plain_password = user_data_in_dict.pop('password')
        user_data_in_dict['password_hash'] = generate_hashed_password(plain_password)
        
        # Create and save user
        new_user = User_Model(**user_data_in_dict)
        session.add(new_user)
        await session.commit()
        await session.refresh(new_user)
        
        return new_user
    
    async def update_user(self,email:str,update_data:Update_User,session:AsyncSession):
        
        update_data_dict = update_data.model_dump()
        
        user_exist = await self.get_user_by_email(email,session)
        
        if not user_exist:
            raise UserAlreadyExists()
        for key,value in update_data_dict.items():
            setattr(user_exist,key,value)
            
        await session.commit()
        await session.refresh(user_exist)
        
        
    async def activation_user(self,email:str,session:AsyncSession):
        
        user_exist : User_Model = await self.get_user_by_email(email,session)
        if not user_exist:
            raise UserNotFound()
        if user_exist.is_verifed:
            raise UserAlreadyVerify()
        user_exist.is_verifed=True
        logging.info(f"User verified successfully: {email}")

        await session.commit()
        await session.refresh(user_exist)
        
      

### server/src/auth/utils.py

import bcrypt
from src.db.config import config
from datetime import timedelta ,datetime,timezone
import jwt
from src.db.config import config
import uuid
from src.err import InvalidToken,TokenExpired
import logging
from itsdangerous import URLSafeTimedSerializer,URLSafeSerializer,SignatureExpired,BadSignature
import uuid
def generate_hashed_password(password: str) -> str:
    """Hash a password using bcrypt"""
    password_bytes = password.encode('utf-8')[:72]
    
    rounds = config.BCRYPT_ROUNDS
    
    salt = bcrypt.gensalt(rounds)  
    hashed = bcrypt.hashpw(password_bytes, salt)
    
    return hashed.decode('utf-8')

def verify_password(password: str, hashed_password: str) -> bool:
    """Verify a password against a bcrypt hash"""
   
    password_bytes = password.encode('utf-8')[:72]
    
    hashed_bytes = hashed_password.encode('utf-8')
    
    # Verify
    return bcrypt.checkpw(password_bytes, hashed_bytes) # return a boolean 


def access_token(user_data:dict,expire:timedelta=None,refresh:bool=False):
    default_time = 30
    payload = {
        "user":user_data,
        "exp":datetime.now(timezone.utc)+ (expire if expire is not None else timedelta(minutes=default_time)) ,
        "jti":str(uuid.uuid4()),
        'refresh_token':refresh
    }

# remember that the exp field is a keyword in the jwt definition so don't make it as expiry this false 
    
    token = jwt.encode(
        payload =payload,
        key = config.jwt_secret,
        algorithm = config.jwt_algorithm)
    
    return token

def decode_token(token_data:str):
    try:
        return jwt.decode(jwt=token_data, 
                          key=config.jwt_secret,
                          algorithms=[config.jwt_algorithm]
                          )
    except jwt.exceptions.ExpiredSignatureError:
        logging.exception("Token expired")
        raise TokenExpired()
    except jwt.InvalidTokenError:
        raise InvalidToken()
    
    except Exception as e :
        logging.exception(f'Unknown error decoding token: {e}')    
    return None


# this calss is intedent to create a safe url for the user to verify his email or reset his password 
# and make the accounts real and active  


class CreationSafeLink(URLSafeTimedSerializer):
    def __init__(self,secret_key:str,salt:str):
        super().__init__(secret_key=secret_key,salt=salt)
        
    def create_safe_url(self,data:dict=None):
        id = str(uuid.uuid4())
        if data is None:
            data={}
            
        data['token_id'] = id
        token = self.dumps(data)
        return token


    def de_serializ_url(self,token:str,max_age=1800):
        try:
            token = self.loads(token,max_age=max_age)
            return  token 
        
        except SignatureExpired as e:
            logging.error(f'Token has expired: {e}')
            raise TokenExpired()  
        
        except BadSignature as e:
            logging.error(f'Invalid token signature: {e}')
            raise InvalidToken()  
        
        except Exception as e:
            logging.exception(f'Unknown error decoding token: {e}')
            
            

### server/src/book/books_db.py
books = [
  {
     "id":1,
    "title":"how become a smarter one",
    "author":"john17",
     "publisher":"john",
      "page_count":44,
    "category":"scfi ",
     "language":"emglish",
 
  
    
  },
  {
   "id":1,
    "title":"how become a smarter one",
    "author":"john17",
     "publisher":"john",
      "page_count":44,
    "category":"scfi ",
     "language":"emglish",
 
  
  }
]


### server/src/book/routes.py

from fastapi import APIRouter, status, Depends, UploadFile, File
from fastapi.responses import FileResponse
from fastapi.exceptions import HTTPException
from typing import List
from .schema import Book, UpdateBook, CreateBook,ReviewBook
from .service import BookService
from sqlmodel.ext.asyncio.session import AsyncSession
from src.db.main import get_session
from src.auth.dependencies import AccessTokenBearer,CheckRoler,get_current_user
from src.db.models import User
import os
import shutil
import uuid
from pathlib import Path


# Create uploads directory
UPLOAD_DIR = Path("uploads/ebooks")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

ALLOWED_EXTENSIONS = {".pdf", ".epub", ".mobi", ".azw", ".azw3"}
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB

# objects definations 
book_router = APIRouter()
 
book_service = BookService()  

Bearer = AccessTokenBearer()

checkroler = Depends(CheckRoler(['admin','user']))


@book_router.get('/hello')  
async def hi():
    return {"message": "hello"}


@book_router.get('/', response_model=List[ReviewBook],dependencies=[checkroler])  
async def get_books(session: AsyncSession = Depends(get_session),
                    _:dict=Depends(Bearer)):
    
    
    books = await book_service.get_books(session)
    return books


@book_router.get('/{id}', response_model=ReviewBook,dependencies=[checkroler])  
async def get_a_book(id: str, 
                     session: AsyncSession = Depends(get_session)):
    get_book = await book_service.get_book(id, session)
    if not get_book:
        raise HTTPException(status_code=404, detail="Book not found")
    return get_book

"""get the user books only """
#  here we can get the user id from the get me route in the auth.routes we can excatract the id from the token

@book_router.get('/user/{user_id}', response_model=list[Book],dependencies=[checkroler])  
async def get_user_books(
                     user_id: str, 
                     session: AsyncSession = Depends(get_session)
                     ):
    
    get_book = await book_service.get_user_books(user_id, session)
    if not get_book:
        raise HTTPException(status_code=404, detail="Book not found")
    return get_book



@book_router.post('/create_book', status_code=status.HTTP_201_CREATED, response_model=Book,dependencies=[checkroler])  
async def create_book(data: CreateBook,
                      session: AsyncSession = Depends(get_session),
                      _:dict=Depends(Bearer),
                      user_data:User=Depends(get_current_user)): 

    user_id = user_data.id
    
    new_book = await book_service.create_book(data, user_id,session)
    return new_book





@book_router.patch('/update_book/{id}', response_model=Book,dependencies=[checkroler]) 
async def update_a_book(id: str
                        , data: UpdateBook
                        , session: AsyncSession = Depends(get_session)): 
    updated_book = await book_service.update_book(id, data, session)
    if not updated_book:
        raise HTTPException(status_code=404, detail="Book not found")
    return updated_book


@book_router.delete('/delete_book/{id}', status_code=status.HTTP_204_NO_CONTENT,dependencies=[checkroler])
async def delete_book(id: str,
                      session: AsyncSession = Depends(get_session)):
    deleted_book = await book_service.delete_book(id, session)
    if deleted_book is None:
        raise HTTPException(status_code=404, detail="Book not found")
    return None  # For 204 responses


@book_router.post('/upload_ebook/{book_id}', dependencies=[checkroler])
async def upload_ebook(
    book_id: str,
    file: UploadFile = File(...),
    session: AsyncSession = Depends(get_session),
    user_data: User = Depends(get_current_user)
):
    # 1. Validate file type
    file_ext = Path(file.filename).suffix.lower()
    if file_ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=400, 
            detail=f"File type not allowed. Supported: {', '.join(ALLOWED_EXTENSIONS)}"
        )
    
    # 2. Check file size
    file.file.seek(0, 2)  # Seek to end
    file_size = file.file.tell()
    file.file.seek(0)  # Reset to start
    
    if file_size > MAX_FILE_SIZE:
        raise HTTPException(status_code=400, detail="File too large (max 50MB)")
    
    # 3. Get the book and verify ownership
    book = await book_service.get_book(book_id, session)
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    # Ensure user_id comparison is safe
    if str(book.user_id) != str(user_data.id):
        raise HTTPException(status_code=403, detail="Not your book")
    
    # 4. Generate unique filename
    unique_filename = f"{uuid.uuid4()}{file_ext}"
    file_path = UPLOAD_DIR / unique_filename
    
    # 5. Save file to disk
    try:
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save file: {str(e)}")
    
    # 6. Update book record in DB
    book.file_path = str(file_path)
    book.file_size = file_size
    book.file_type = file_ext.lstrip('.')
    
    await session.commit()
    await session.refresh(book)
    
    return {
        "message": "Ebook uploaded successfully",
        "file_path": str(file_path),
        "file_size": file_size,
        "file_type": file_ext.lstrip('.')
    }


@book_router.get('/download_ebook/{book_id}', dependencies=[checkroler])
async def download_ebook(
    book_id: str,
    session: AsyncSession = Depends(get_session),
    user_data: User = Depends(get_current_user)
):
    book = await book_service.get_book(book_id, session)
    
    if not book:
        raise HTTPException(status_code=404, detail="Book not found")
    
    if not book.file_path:
        raise HTTPException(status_code=404, detail="No ebook file uploaded")
    
    if not os.path.exists(book.file_path):
        raise HTTPException(status_code=404, detail="File not found on server")
    
    # Return file for download
    return FileResponse(
        path=book.file_path,
        filename=f"{book.title}.{book.file_type}",
        media_type="application/octet-stream"
    )

### server/src/book/schema.py

from pydantic import BaseModel 
import uuid
from datetime import datetime
from src.reviews.schema import Review
from typing import List
class Book(BaseModel): 
    id: uuid.UUID
    title: str
    author: str
    publisher: str
    page_count: int
    category: str
    description:str
    language: str
    published_date: datetime
    created_at: datetime | None = None  # âœ… Made optional
    updated_at: datetime | None = None  # âœ… Made optional



class CreateBook(BaseModel):  
    title: str
    author: str
    publisher: str
    published_date: datetime
    page_count: int
    category: str
    description:str
    language: str

  
class UpdateBook(BaseModel): 
    title: str
    author: str
    publisher: str
    published_date: datetime
    page_count: int
    category: str
    description:str
    language: str




class ReviewBook(Book):
    
   reviews:List[Review]

### server/src/book/service.py

from sqlmodel.ext.asyncio.session import AsyncSession
from .schema import CreateBook, UpdateBook  # âœ… Fixed: Capital letters
from sqlmodel import select, desc
from src.db.models import Book as BookModel  # âœ… Fixed: Import renamed to avoid conflict
import uuid

class BookService:
    
    async def get_books(self, session: AsyncSession):
        statement = select(BookModel).order_by(desc(BookModel.created_at))
        result = await session.exec(statement)
        return result.all()
    
    async def get_book(self, book_id: str, session: AsyncSession):
        try:
            statement = select(BookModel).where(BookModel.id == book_id)
            result = await session.exec(statement)
            book = result.first()
            
            if not book:
                return None  # âœ… Better to return None instead of raising ValueError
            
            return book

        except Exception as e:
            print(f"Error retrieving book: {e}")
            return None
        
        
    async def get_user_books(self,user_id:str, session: AsyncSession):
        statement = select(BookModel).where(BookModel.user_id==user_id).order_by(desc(BookModel.created_at))
        result = await session.exec(statement)
        return result.all()
           
        
    
    async def create_book(self, data: CreateBook, id:uuid.UUID, session: AsyncSession):
        new_book_dict = data.model_dump()
        
        new_book = BookModel(**new_book_dict)
        new_book.user_id = id
        session.add(new_book) 
        
        await session.commit()
        await session.refresh(new_book) 
        return new_book
    
    async def update_book(self, book_id: str, data: UpdateBook, session: AsyncSession):
        updated_book = data.model_dump()  
        try:
            get_the_book = await self.get_book(book_id, session)
            if get_the_book:
                for key, value in updated_book.items():
                    setattr(get_the_book, key, value)
                    
                await session.commit()
                await session.refresh(get_the_book)
                return get_the_book
            else:
                print(f'There is no book with this id {book_id}')
                return None

        except Exception as e:
            print(f"There was an error updating this book id {book_id}: {e}")
            return None  # âœ… Added return
    
    async def delete_book(self, book_id: str, session: AsyncSession):
        try:
            is_book_exist = await self.get_book(book_id, session)
            if is_book_exist:
                await session.delete(is_book_exist)
                await session.commit()
                print(f"Book with ID {book_id} deleted successfully.")
                return True  # âœ… Changed: Return True on success
            else:
                print(f"There is no book with this id {book_id}")
                return None
        except Exception as e:
            print(f"There was an error when deleting this book: {e}")
            return None  # âœ… Added return

### server/src/reviews/routes.py
from fastapi import APIRouter,Depends
from .service import Review_Service
from src.auth.dependencies import get_current_user,CheckRoler
from sqlmodel.ext.asyncio.session import AsyncSession
from .schema import CreateReview
from src.db.models import Review,User
from src.db.main import get_session
from src.book.schema import ReviewBook

review_router = APIRouter()

review_service = Review_Service()

checkroler = Depends(CheckRoler(['admin','user']))


@review_router.post('/add_review/{book_id}',response_model=Review,dependencies=[checkroler])
async def add_review(review_data:CreateReview,
                     book_id:str,
                     user_details:User=Depends(get_current_user),
                     session:AsyncSession=Depends(get_session)):
    
    
    user_email =user_details.email
    
    return await review_service.add_review(review_data,
                              book_id,
                              user_email,
                              session)
    
    

### server/src/reviews/schema.py
from pydantic import BaseModel,Field
import uuid
from datetime import datetime


class Review(BaseModel):
    id: uuid.UUID 
    
    rating:int=Field(
        le=5,
    )
    
    comment:str=Field(max_length=80)
    user_id:uuid.UUID | None 
    book_id:uuid.UUID | None 
    created_at:datetime | None
    updated_at: datetime | None

class CreateReview(BaseModel):
 
    rating:int=Field(
        le=5,
    )
    comment:str=Field(max_length=80)
 
 

### server/src/reviews/service.py
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlmodel import select
from src.db.models import User as User_Model
from .schema import CreateReview
from fastapi.exceptions import HTTPException
from src.db.models import Review,User
from fastapi import status,Depends
from src.auth.service import User_Service
from src.book.service import BookService
from src.db.main import get_session
import logging
class Review_Service:
    
    
    
    async def add_review(self,data_review:CreateReview,
                         book_id:str,
                         email:str,
                         session:AsyncSession=Depends(get_session))->object:
        
        
        user_service = User_Service()
        book_service = BookService()
        
        

        try:
            
            user = await user_service.get_user_by_email(email,session)
            
            if not user :
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND)
                
                
            book = await book_service.get_book(book_id,session)
            
            if not book :
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND)
                
            
            data_review_dict = data_review.model_dump()
            
            new_review = Review(**data_review_dict)
            new_review.book = book
            new_review.user = user
            
            session.add(new_review)
            await session.commit()
            await session.refresh(new_review)
            
            return new_review
    
              
        except Exception as e :
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail=f'ther was an erro {e}')
    

### server/src/mailserver/routes.py
from fastapi import APIRouter
from .schema import Mail_send_Mode
from .service import welcome_message,mail
mail_router = APIRouter()

@mail_router.post('/welcome')
async def sending_mail(mails:Mail_send_Mode):
    
  
    recepients = mails.emails
    message =await welcome_message(recepients=recepients)
    
    await mail.send_message(message)
    return {'message':'Email has been sent'}
    
    

### server/src/mailserver/schema.py
from pydantic import BaseModel



class Mail_send_Mode(BaseModel):
    emails:list[str]
  

### server/src/mailserver/service.py
from fastapi_mail import ConnectionConfig, MessageType, MessageSchema, FastMail
from src.db.config import config as Config
from pathlib import Path
from jinja2 import Template

BASE_DIR = Path(__file__).resolve().parent

Mail_Config = ConnectionConfig( 
    MAIL_USERNAME=Config.MAIL_USERNAME,
    MAIL_PASSWORD=Config.MAIL_PASSWORD,
    MAIL_FROM=Config.MAIL_FROM,
    MAIL_PORT=587,
    MAIL_SERVER=Config.MAIL_SERVER,
    MAIL_FROM_NAME=Config.MAIL_FROM_NAME,
    MAIL_STARTTLS=True,
    MAIL_SSL_TLS=False,
    USE_CREDENTIALS=True,
    VALIDATE_CERTS=True,
    TEMPLATE_FOLDER=Path(BASE_DIR, "templates"),
)

mail = FastMail(config=Mail_Config)

async def welcome_message(recepients:str):
    path_content = Path(BASE_DIR,"templates",'welcome.html')
    with open(path_content,'r',encoding='utf-8') as r :
        html_content = r.read()
        

    message = MessageSchema(recipients=[recepients],subject='Welcome to Blurz_Book',subtype=MessageType.html ,body=html_content)
    return message

"""notice the data_variables paramater is responsible for replacing the values in the html file like links """
def send_email(recepients: list[str], subject:str,html_message_path:str,data_variables:dict | None = None): 
    
    path_content = Path(BASE_DIR, "templates", html_message_path)
    
    with open(path_content, 'r', encoding='utf-8') as r:
        html_template = r.read()
    

    template = Template(html_template)
    html_content = template.render(**data_variables)
    
    message = MessageSchema(
        recipients=recepients,
        subject=subject,
        subtype=MessageType.html,
        body=html_content,
    )
    
    return message



### server/src/mailserver/templates/verify_message.html
<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
    <h1>Verify your Email</h1>
    <p>here your link to verify your account ,
  notice this  link is valid about 15 minutes click on <a href="{{link}}">link</a> to verify your email</p>
</body>
</html>



### server/src/celery/celery_config.py
from src.db.config import config

broker_url = config.Redis_Url
result_backend = config.Redis_Url
broker_conection_retry_on_startup = True

task_serializer = 'json'
result_serializer = 'json'
accept_content = ['json']
timezone = 'UTC'
enable_utc = True

FLOWER_UNAUTHENTICATED_API=323

### server/src/celery/celery_tasks.py
from celery import Celery
from asgiref.sync import async_to_sync
from src.mailserver.service import send_email,mail

app  = Celery()

# still don't know how this config works but you must know how is done 

app.config_from_object('src.celery.celery_config')


@app.task()
def bg_send_mail(rec:list[str],sub:str,html_path:str,data_var:dict=None):
    
    message = send_email(recepients=rec,subject=sub,html_message_path=html_path,data_variables=data_var)
    
    # we use here this adapter for making async function work in sync context cause celery is syncrounous  

    async_to_sync(mail.send_message)(message)
    
    print('Email is sent')



### server/src/err.py
from typing import Any
from fastapi.requests import Request
from fastapi.responses import JSONResponse
from fastapi import FastAPI, status


class AppError(Exception):
    """Base class for all application errors"""
    pass


class InvalidToken(AppError):
    """Token is invalid or corrupted"""
    pass


class TokenExpired(AppError):
    """Token has expired"""
    pass


class RevokedToken(AppError):
    """Token has been revoked"""
    pass


class AccessTokenRequired(AppError):
    """Access token is required but not provided"""
    pass


class RefreshTokenRequired(AppError):
    """Refresh token is required but not provided"""
    pass


class UserAlreadyExists(AppError):
    """User with this email already exists"""
    pass


class InvalidCredentials(AppError):
    """Invalid email or password"""
    pass


class InsufficientPermission(AppError):
    """User lacks necessary permissions"""
    pass


class BookNotFound(AppError):
    """Book not found"""
    pass


class TagNotFound(AppError):
    """Tag not found"""
    pass


class TagAlreadyExists(AppError):
    """Tag already exists"""
    pass


class UserNotFound(AppError):
    """User not found"""
    pass


class EmailNotVerified(AppError):
    """User email has not been verified"""
    pass


class VerificationError(AppError):
    """Error during email verification process"""
    pass
class UserAlreadyVerify(AppError):
    """Error during email verification process"""
    pass

class DataNotFound(AppError):
    pass

class PasswordAlreadyReset(AppError):
    pass
class PasswordNotMatced(AppError):
    pass


# Exception registry with proper error codes and messages
register_exception = {
    InvalidToken: {
        "status_code": status.HTTP_401_UNAUTHORIZED,
        "initial_detail": {
            "message": "The provided token is invalid or corrupted",
            "error_code": "invalid_token",
        }
    },
    
    TokenExpired: {
        "status_code": status.HTTP_401_UNAUTHORIZED,
        "initial_detail": {
            "message": "The verification link has expired. Please request a new one",
            "error_code": "token_expired",
        }
    },
    
    RevokedToken: {
        "status_code": status.HTTP_401_UNAUTHORIZED,
        "initial_detail": {
            "message": "This token has been revoked",
            "error_code": "token_revoked",
        }
    },
    
    AccessTokenRequired: {
        "status_code": status.HTTP_401_UNAUTHORIZED,
        "initial_detail": {
            "message": "Access token is required for this operation",
            "error_code": "access_token_required",
        }
    },
    
    RefreshTokenRequired: {
        "status_code": status.HTTP_401_UNAUTHORIZED,
        "initial_detail": {
            "message": "Refresh token is required for this operation",
            "error_code": "refresh_token_required",
        }
    },
    
    UserNotFound: {
        "status_code": status.HTTP_404_NOT_FOUND,
        "initial_detail": {
            "message": "User not found",
            "error_code": "user_not_found",
        }
    },
    
    UserAlreadyExists: {
        "status_code": status.HTTP_409_CONFLICT,
        "initial_detail": {
            "message": "A user with this email already exists",
            "error_code": "user_exists",
        }
    },
    
    InvalidCredentials: {
        "status_code": status.HTTP_401_UNAUTHORIZED,
        "initial_detail": {
            "message": "Invalid email or password",
            "error_code": "invalid_credentials",
        }
    },
    
    InsufficientPermission: {
        "status_code": status.HTTP_403_FORBIDDEN,
        "initial_detail": {
            "message": "You don't have permission to perform this action",
            "error_code": "insufficient_permission",
        }
    },
    
    EmailNotVerified: {
        "status_code": status.HTTP_403_FORBIDDEN,
        "initial_detail": {
            "message": "Please verify your email before logging in",
            "error_code": "email_not_verified",
        }
    },
    
    VerificationError: {
        "status_code": status.HTTP_403_FORBIDDEN,
        "initial_detail": {
            "message": "There was an error verifying your email",
            "error_code": "verification_error",
            'resoluttion':'verify your email first'
        }
    },
    
    BookNotFound: {
        "status_code": status.HTTP_404_NOT_FOUND,
        "initial_detail": {
            "message": "Book not found",
            "error_code": "book_not_found",
        }
    },
    
    TagNotFound: {
        "status_code": status.HTTP_404_NOT_FOUND,
        "initial_detail": {
            "message": "Tag not found",
            "error_code": "tag_not_found",
        }
    },
    
    TagAlreadyExists: {
        "status_code": status.HTTP_409_CONFLICT,
        "initial_detail": {
            "message": "A tag with this name already exists",
            "error_code": "tag_exists",
        }
    },
    
    UserAlreadyVerify: {
        "status_code": status.HTTP_400_BAD_REQUEST,
        "initial_detail": {
            "message": 'already verify ',
            "error_code": "Verified email",
        }
    },
    PasswordAlreadyReset: {
        "status_code": status.HTTP_400_BAD_REQUEST,
        "initial_detail": {
            "message": 'already reset with this URL ',
            "error_code": "password is reset and this link is expired  ",
        }
    },           
    PasswordNotMatced: {
        "status_code": status.HTTP_400_BAD_REQUEST,
        "initial_detail": {
            "message": 'passwords not matched  ',
            "error_code": "NOT MATCHED  ",

        }
    },
   
    DataNotFound: {
        "status_code": status.HTTP_400_BAD_REQUEST,
        "initial_detail": {
            "message": 'NO data provided  ',
            "error_code": "lackness of data ",
        }
    },
}


def registery(status_code: int, detail: Any):
    """Create exception handler with proper status code and detail"""
    async def error_handler(req: Request, exc: AppError):
        return JSONResponse(
            content={
                "status_code": status_code,
                "detail": detail
            },
            status_code=status_code
        )
    return error_handler


def creation_exceptions(app: FastAPI):
    """Register all exception handlers with the FastAPI app"""
    for excp, exc_info in register_exception.items():
        app.add_exception_handler(
            excp,
            registery(
                status_code=exc_info['status_code'],
                detail=exc_info['initial_detail']
            )
        )

### server/src/errors.py
from typing import Any
from fastapi.requests import Request
from fastapi.responses import JSONResponse
from fastapi import FastAPI,status
class AppError(Exception):
    """This is the base class of the entire App"""
    
    

class InvalidToken(AppError):
    """User has provided an invalid or expired token"""
    pass

class RevokedToken(AppError):
    """User has provided a token that has been revoked like added to the blacklist """
    pass

class AccessTokenRequired(AppError):
    """User has provided a refresh token when an access token is needed"""
    pass

class RefreshTokenRequired(AppError):
    """User has provided an access token when a refresh token is needed"""
    pass

class UserAlreadyExists(AppError):
    """User has provided an email for a user who exists during sign up."""
    pass

class InvalidCredentials(AppError):
    """User has provided wrong email or password during log in."""
    pass

class InsufficientPermission(AppError):
    """User does not have the necessary permissions to perform an action."""
    pass

class BookNotFound(AppError):
    """Book Not found"""
    pass

class TagNotFound(AppError):
    """Tag Not found"""
    pass

class TagAlreadyExists(AppError):
    """Tag already exists"""
    pass

class UserNotFound(AppError):
    """User Not found"""
    pass




def create_exception_handler(status_code:int,
                              initial_detail:Any):
    
    async def handler_excption(request:Request,exc:AppError):
        return JSONResponse(content={"status_code":status_code,"detail":initial_detail})
    
    return handler_excption


def register_error_handlers(app: FastAPI):
    app.add_exception_handler(
        exc_class_or_status_code=UserAlreadyExists,
        handler=create_exception_handler(
            status_code=status.HTTP_403_FORBIDDEN,
            initial_detail={
                "message": "User with email already exists",
                "error_code": "user_exists",
            },
        ),
    )

    app.add_exception_handler(
        UserNotFound,
        create_exception_handler(
            status_code=status.HTTP_404_NOT_FOUND,
            initial_detail={
                "message": "User not found",
                "error_code": "user_not_found",
            },
        ),
    )
    app.add_exception_handler(
        BookNotFound,
        create_exception_handler(
            status_code=status.HTTP_404_NOT_FOUND,
            initial_detail={
                "message": "Book not found",
                "error_code": "book_not_found",
            },
        ),
    )
    app.add_exception_handler(
        InvalidCredentials,
        create_exception_handler(
            status_code=status.HTTP_400_BAD_REQUEST,
            initial_detail={
                "message": "Invalid Email Or Password",
                "error_code": "invalid_email_or_password",
            },
        ),
    )
    app.add_exception_handler(
        InvalidToken,
        create_exception_handler(
            status_code=status.HTTP_401_UNAUTHORIZED,
            initial_detail={
                "message": "Token is invalid Or expired",
                "resolution": "Please get new token",
                "error_code": "invalid_token",
            },
        ),
    )
    app.add_exception_handler(
        RevokedToken,
        create_exception_handler(
            status_code=status.HTTP_401_UNAUTHORIZED,
            initial_detail={
                "message": "Token is invalid or has been revoked",
                "resolution": "Please get new token",
                "error_code": "token_revoked",
            },
        ),
    )
    app.add_exception_handler(
        AccessTokenRequired,
        create_exception_handler(
            status_code=status.HTTP_401_UNAUTHORIZED,
            initial_detail={
                "message": "Please provide a valid access token",
                "resolution": "Please get an access token",
                "error_code": "access_token_required",
            },
        ),
    )
    app.add_exception_handler(
        RefreshTokenRequired,
        create_exception_handler(
            status_code=status.HTTP_403_FORBIDDEN,
            initial_detail={
                "message": "Please provide a valid refresh token",
                "resolution": "Please get an refresh token",
                "error_code": "refresh_token_required",
            },
        ),
    )
    app.add_exception_handler(
        InsufficientPermission,
        create_exception_handler(
            status_code=status.HTTP_401_UNAUTHORIZED,
            initial_detail={
                "message": "You do not have enough permissions to perform this action",
                "error_code": "insufficient_permissions",
            },
        ),
    )
    app.add_exception_handler(
        TagNotFound,
        create_exception_handler(
            status_code=status.HTTP_404_NOT_FOUND,
            initial_detail={"message": "Tag Not Found", "error_code": "tag_not_found"},
        ),
    )

    app.add_exception_handler(
        TagAlreadyExists,
        create_exception_handler(
            status_code=status.HTTP_401_UNAUTHORIZED,
            initial_detail={
                "message": "Tag Already exists",
                "error_code": "tag_exists",
            },
        ),
    )

    app.add_exception_handler(
        BookNotFound,
        create_exception_handler(
            status_code=status.HTTP_404_NOT_FOUND,
            initial_detail={
                "message": "Book Not Found",
                "error_code": "book_not_found",
            },
        ),
    )

    @app.exception_handler(500)
    async def internal_server_error(request, exc):

        return JSONResponse(
            content={
                "message": "Oops! Something went wrong",
                "error_code": "server_error",
            },
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        )

### server/src/middleware.py
from fastapi import FastAPI,status
from fastapi.requests import Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import time 


"""simple middleware type one"""


 #   the functions of the middleware are : logging request , authuntication like in the dependencies injection 
 # , cors origins and prevent host attack  , Rate lImiting , 
 
def custome_simple_middle(app:FastAPI):
    
    @app.middleware('http')
    
    async def custome_logging(request:Request,call_next):
        
        start_time = time.time()
                
        logging = await call_next(request)
        
        prcessed_time = time.time() - start_time
         
         
        message = f"{request.client.host}:{request.client.port} - {request.method} - {request.url.path} -completed after {prcessed_time}s"
        
        print(message)
        
        return logging
    
    app.add_middleware(
    CORSMiddleware,
    allow_origins= ['*'] ,
    allow_methods=['GET','POST','PATCH','DELETE'],
    allow_headers=['*'],
    allow_credentials = True,
       
    )
    
    
    app.add_middleware(
        TrustedHostMiddleware ,
        allowed_hosts=['*'],

    )
    
    
        
        

### client/package.json
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^2.2.5",
    "@stripe/react-stripe-js": "^2.7.1",
    "@stripe/stripe-js": "^3.5.0",
    "axios": "^1.7.2",
    "chart.js": "^4.4.3",
    "dayjs": "^1.11.11",
    "dompurify": "^3.2.6",
    "firebase": "^10.12.2",
    "framer-motion": "^10.16.0",
    "lottie-react": "^2.4.0",
    "lucide-react": "^0.522.0",
    "papaparse": "^5.4.1",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.2.1",
    "react-loading-skeleton": "^3.4.0",
    "react-modal": "^3.16.1",
    "react-paginate": "^8.2.0",
    "react-redux": "^9.1.2",
    "react-responsive-carousel": "^3.2.23",
    "react-router-dom": "^6.23.1",
    "react-table": "^7.8.0",
    "react-toastify": "^10.0.5"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@types/dompurify": "^3.0.5",
    "@types/papaparse": "^5.3.14",
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-table": "^7.7.20",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "postcss": "^8.4.38",
    "prettier": "^3.5.3",
    "tailwindcss": "^3.4.3",
    "typescript": "^5.2.2",
    "vite": "^5.2.0",
    "vitest": "^3.2.3"
  }
}

### client/postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

### client/tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: "#1B5A7D",
        secondary: "#EDA415",
        tertiary: "#E2F4FF",
      },
    },
  },
  plugins: [],
}

### client/index.html
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blurz Books</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>
</html>

### client/src/main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';
import { AuthProvider } from './context/AuthContext';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <App />
    </AuthProvider>
  </React.StrictMode>
);






### client/src/App.jsx
import React, { useState } from 'react';
import { useAuth } from './context/AuthContext';
import AuthPage from './components/AuthPage';
import Dashboard from './components/Dashboard';
import LoadingSpinner from './components/LoadingSpinner';
import api from './services/api';

function App() {
  const { user, login, loading } = useAuth();
  const [authError, setAuthError] = useState('');
  const [settings] = useState({
    darkMode: localStorage.getItem('darkMode') === 'true',
  });

  const handleLogin = async (email, password) => {
    setAuthError('');
    try {
      const response = await api.post('/auth/login', { email, password });
      
      console.log('Login response:', response.data); // Debug log
      
      // Extract data from server response
      const { access_token, refresh_token, username, user_id, email: userEmail } = response.data;
      
      // Verify tokens exist
      if (!access_token || !refresh_token) {
        throw new Error('Tokens not received from server');
      }
      
      // Structure user data for client
      const userData = {
        user_id,
        username,
        email: userEmail,
      };
      
      const tokens = {
        access_token,
        refresh_token,
      };
      
      console.log('Calling login with:', { userData, tokens }); // Debug log
      
      // Call login from context
      login(userData, tokens);
      
      console.log('Login successful'); // Debug log
      
    } catch (error) {
      console.error('Login error:', error); // Debug log
      
      // Handle nested error structure from server
      const errorMessage = 
        error.response?.data?.detail?.message || 
        error.response?.data?.detail || 
        error.response?.data?.message ||
        error.userMessage || 
        error.message ||
        'Login failed. Please check your credentials.';
      setAuthError(errorMessage);
    }
  };

  const handleSignup = async (formData) => {
    setAuthError('');
    try {
      const response = await api.post('/auth/signup', formData);
      console.log('Signup response:', response.data); // Debug log
      
      setAuthError('');
      alert('Account created! Please check your email to verify your account before logging in.');
    } catch (error) {
      console.error('Signup error:', error); // Debug log
      
      // Handle nested error structure
      const errorMessage = 
        error.response?.data?.detail?.message || 
        error.response?.data?.detail || 
        error.response?.data?.message ||
        'Signup failed. Please try again.';
      setAuthError(errorMessage);
    }
  };

  if (loading) {
    return (
      <div className={`min-h-screen ${settings.darkMode ? 'bg-gray-900' : 'bg-gray-50'} flex items-center justify-center`}>
        <LoadingSpinner darkMode={settings.darkMode} />
      </div>
    );
  }

  return user ? (
    <Dashboard />
  ) : (
    <AuthPage
      onLogin={handleLogin}
      onSignup={handleSignup}
      settings={settings}
      error={authError}
    />
  );
}

export default App;

### client/src/index.css
@import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;




body {
  font-family: 'Poppins', sans-serif;
}

.scrollbar-hide::-webkit-scrollbar {
  display: none;
}

.scrollbar-hide {
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}

/* Pagination Styling */
.pagination {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

.page-item {
  margin: 0 5px;
  cursor: pointer;
}

.page-link {
  padding: 8px 16px;
  border: 1px solid #ddd;
  color: #007bff;
  text-decoration: none;
}

.page-link:hover {
  background-color: #007bff;
  color: white;
}

.active .page-link {
  background-color: #007bff;
  color: white;
  border-color: #007bff;
}

.disabled .page-link {
  color: #6c757d;
  pointer-events: none;
}

/* Loader */

/* components/loader.css */
.loader {
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-top: 4px solid #000;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}



### client/src/vite-env.d.ts
/// <reference types="vite/client" />

### client/src/context/AuthContext.jsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import api from '../services/api';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check if user is already logged in
    const token = localStorage.getItem('access_token');
    const userData = localStorage.getItem('user_data');
    
    if (token && userData) {
      try {
        setUser(JSON.parse(userData));
      } catch (error) {
        console.error('Error parsing user data:', error);
        localStorage.clear();
      }
    }
    setLoading(false);
  }, []);

  const login = (userData, tokens) => {
    // Fixed typo: acess_token -> access_token
    localStorage.setItem('access_token', tokens.access_token);
    localStorage.setItem('refresh_token', tokens.refresh_token);
    localStorage.setItem('user_data', JSON.stringify(userData));
    setUser(userData);
  };

  const logout = async () => {
    try {
      await api.post('/auth/logout');
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.clear();
      setUser(null);
    }
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

### client/src/hooks/useToast.jsx
import { useState } from 'react';
import { X, CheckCircle, AlertCircle } from 'lucide-react';

let toastCounter = 0; // Global counter for unique IDs

const useToast = () => {
  const [toasts, setToasts] = useState([]);

  const showToast = (message, type = 'info') => {
    const id = `toast-${Date.now()}-${toastCounter++}`; // Unique ID combining timestamp and counter
    
    const newToast = {
      id,
      message,
      type,
    };

    setToasts((prev) => [...prev, newToast]);

    // Auto remove after 5 seconds
    setTimeout(() => {
      removeToast(id);
    }, 5000);
  };

  const removeToast = (id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  };

  const ToastContainer = () => (
    <div className="fixed top-4 right-4 z-50 space-y-2 max-w-md">
      {toasts.map((toast) => (
        <div
          key={toast.id}
          className={`flex items-center gap-3 px-4 py-3 rounded-lg shadow-lg transform transition-all duration-300 ${
            toast.type === 'success'
              ? 'bg-green-500 text-white'
              : toast.type === 'error'
              ? 'bg-red-500 text-white'
              : 'bg-blue-500 text-white'
          }`}
        >
          {toast.type === 'success' && <CheckCircle className="w-5 h-5" />}
          {toast.type === 'error' && <AlertCircle className="w-5 h-5" />}
          <span className="flex-1">{toast.message}</span>
          <button
            onClick={() => removeToast(toast.id)}
            className="hover:opacity-80 transition-opacity"
          >
            <X className="w-5 h-5" />
          </button>
        </div>
      ))}
    </div>
  );

  return { showToast, ToastContainer };
};

export default useToast;

### client/src/services/api.js
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api/v1';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
      console.log('Adding token to request:', config.url); // Debug log
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    console.log('API Error:', {
      status: error.response?.status,
      url: originalRequest?.url,
      retry: originalRequest?._retry
    }); // Debug log

    // Handle 401 errors (token expired)
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refresh_token');
        console.log('Attempting token refresh, has refresh token:', !!refreshToken); // Debug log
        
        if (refreshToken) {
          // Create a new axios instance without interceptors for refresh request
          const refreshResponse = await axios.post(
            `${API_BASE_URL}/auth/refresh_token`,
            { refresh_token: refreshToken },
            {
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${refreshToken}`
              }
            }
          );

          console.log('Refresh response:', refreshResponse.data); // Debug log

          const { access_token } = refreshResponse.data;
          
          if (!access_token) {
            throw new Error('No access token in refresh response');
          }
          
          localStorage.setItem('access_token', access_token);
          console.log('New access token stored'); // Debug log

          // Retry original request with new token
          originalRequest.headers.Authorization = `Bearer ${access_token}`;
          return api(originalRequest);
        } else {
          console.log('No refresh token available'); // Debug log
          throw new Error('No refresh token available');
        }
      } catch (refreshError) {
        console.error('Token refresh failed:', refreshError); // Debug log
        // Refresh failed, logout user
        localStorage.clear();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    // Handle 403 errors (email not verified)
    if (error.response?.status === 403) {
      const detail = error.response?.data?.detail;
      if (detail) {
        if (typeof detail === 'object' && detail.message) {
          error.userMessage = detail.message;
        } else if (typeof detail === 'string' && (detail.includes('verify') || detail.includes('verification'))) {
          error.userMessage = 'Please verify your email before continuing. Check your inbox!';
        }
      }
    }

    return Promise.reject(error);
  }
);

export default api;

### client/src/components/AddBookForm.jsx
import React, { useState } from "react";


const AddBookForm = ({ onAdd, onCancel, settings }) => {
  const [formData, setFormData] = useState({
    title: '',
    author: '',
    publisher: '',
    published_date: '',
    page_count: '',
    category: '',
    description: '',
    language: '',
  });

  const cardClass = settings.darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = settings.darkMode ? 'text-white' : 'text-gray-900';

  const handleSubmit = (e) => {
    e.preventDefault();
    onAdd(formData);
  };

  return (
    <div className={`${cardClass} rounded-xl shadow-lg p-8`}>
      <h2 className={`text-2xl font-bold ${textClass} mb-6`}>Add New Book</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className={`block text-sm font-medium ${textClass} mb-2`}>Title *</label>
          <input
            type="text"
            required
            value={formData.title}
            onChange={(e) => setFormData({ ...formData, title: e.target.value })}
            className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
          />
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Author *</label>
            <input
              type="text"
              required
              value={formData.author}
              onChange={(e) => setFormData({ ...formData, author: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Publisher *</label>
            <input
              type="text"
              required
              value={formData.publisher}
              onChange={(e) => setFormData({ ...formData, publisher: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Category *</label>
            <input
              type="text"
              required
              value={formData.category}
              onChange={(e) => setFormData({ ...formData, category: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Language *</label>
            <input
              type="text"
              required
              value={formData.language}
              onChange={(e) => setFormData({ ...formData, language: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Page Count *</label>
            <input
              type="number"
              required
              min="1"
              value={formData.page_count}
              onChange={(e) => setFormData({ ...formData, page_count: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Published Date *</label>
            <input
              type="date"
              required
              value={formData.published_date}
              onChange={(e) => setFormData({ ...formData, published_date: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
        </div>

        <div>
          <label className={`block text-sm font-medium ${textClass} mb-2`}>Description *</label>
          <textarea
            required
            rows="4"
            value={formData.description}
            onChange={(e) => setFormData({ ...formData, description: e.target.value })}
            className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
          />
        </div>

        <div className="flex gap-4">
          <button
            type="submit"
            className="flex-1 bg-blue-500 text-white py-3 rounded-lg font-semibold hover:bg-blue-600 transition"
          >
            Add Book
          </button>
          <button
            type="button"
            onClick={onCancel}
            className={`flex-1 py-3 rounded-lg font-semibold ${settings.darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'} hover:opacity-80 transition`}
          >
            Cancel
          </button>
        </div>
      </form>
    </div>
  );
};
export default AddBookForm;

### client/src/components/AuthPage.jsx
import React, { useState } from "react";
import Logo from './Logo';

const AuthPage = ({ onLogin, onSignup, settings, error }) => {
  const [isLogin, setIsLogin] = useState(true);
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    username: '',
    first_name: '',
    last_name: '',
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (isLogin) {
      onLogin(formData.email, formData.password);
    } else {
      onSignup(formData);
    }
  };

  const bgClass = settings.darkMode ? 'bg-gray-900' : 'bg-gradient-to-br from-blue-50 to-indigo-100';
  const cardClass = settings.darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = settings.darkMode ? 'text-white' : 'text-gray-900';
  const textSecondary = settings.darkMode ? 'text-gray-400' : 'text-gray-600';

  return (
    <div className={`min-h-screen ${bgClass} flex items-center justify-center p-4`}>
      <div className={`${cardClass} rounded-2xl shadow-xl p-8 w-full max-w-md`}>
        <div className="text-center mb-8">
          <div className="flex justify-center mb-4">
            <Logo size="large" darkMode={settings.darkMode} />
          </div>
          <p className={textSecondary}>Manage your book collection</p>
        </div>

        {/* Error Message */}
        {error && (
          <div className="mb-4 p-3 bg-red-500 bg-opacity-10 border border-red-500 rounded-lg">
            <p className="text-red-500 text-sm">{error}</p>
          </div>
        )}

        <div className="flex gap-2 mb-6">
          <button
            onClick={() => setIsLogin(true)}
            className={`flex-1 py-2 rounded-lg font-medium transition-colors ${
              isLogin ? 'bg-blue-500 text-white' : `${settings.darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'}`
            }`}
          >
            Sign In
          </button>
          <button
            onClick={() => setIsLogin(false)}
            className={`flex-1 py-2 rounded-lg font-medium transition-colors ${
              !isLogin ? 'bg-blue-500 text-white' : `${settings.darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'}`
            }`}
          >
            Sign Up
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {!isLogin && (
            <>
              <div>
                <label className={`block text-sm font-medium mb-2 ${textClass}`}>Username</label>
                <input
                  type="text"
                  required
                  value={formData.username}
                  onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                  className={`w-full px-4 py-3 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all`}
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className={`block text-sm font-medium mb-2 ${textClass}`}>First Name</label>
                  <input
                    type="text"
                    required
                    value={formData.first_name}
                    onChange={(e) => setFormData({ ...formData, first_name: e.target.value })}
                    className={`w-full px-4 py-3 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all`}
                  />
                </div>
                <div>
                  <label className={`block text-sm font-medium mb-2 ${textClass}`}>Last Name</label>
                  <input
                    type="text"
                    required
                    value={formData.last_name}
                    onChange={(e) => setFormData({ ...formData, last_name: e.target.value })}
                    className={`w-full px-4 py-3 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all`}
                  />
                </div>
              </div>
            </>
          )}

          <div>
            <label className={`block text-sm font-medium mb-2 ${textClass}`}>Email</label>
            <input
              type="email"
              required
              value={formData.email}
              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
              className={`w-full px-4 py-3 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all`}
              placeholder="you@example.com"
            />
          </div>

          <div>
            <label className={`block text-sm font-medium mb-2 ${textClass}`}>Password</label>
            <input
              type="password"
              required
              minLength={8}
              value={formData.password}
              onChange={(e) => setFormData({ ...formData, password: e.target.value })}
              className={`w-full px-4 py-3 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all`}
              placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
            />
          </div>

          <button
            type="submit"
            className="w-full bg-blue-500 text-white py-3 rounded-lg font-medium hover:bg-blue-600 transition-colors"
          >
            {isLogin ? 'Sign In' : 'Create Account'}
          </button>
        </form>
      </div>
    </div>
  );
};

export default AuthPage;








// In Dashboard.jsx - Add this import at the top:

// Then replace the header logo section with:


### client/src/components/BookCard.jsx
import React,{useState} from "react";
import { Star } from "lucide-react";
const BookCard = ({ book, onClick, settings }) => {
  const avgRating = book.reviews?.length > 0
    ? (book.reviews.reduce((sum, r) => sum + r.rating, 0) / book.reviews.length).toFixed(1)
    : 'N/A';

  const cardClass = settings.darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = settings.darkMode ? 'text-white' : 'text-gray-900';
  const textSecondary = settings.darkMode ? 'text-gray-400' : 'text-gray-600';

  return (
    <div 
      onClick={onClick}
      className={`${cardClass} rounded-xl shadow-lg hover:shadow-2xl transition-all p-6 cursor-pointer transform hover:-translate-y-1`}
    >
      <h3 className={`text-xl font-bold ${textClass} mb-2 line-clamp-2`}>{book.title}</h3>
      <p className={`${textSecondary} mb-1`}>by {book.author}</p>
      <p className={`text-sm ${textSecondary} mb-2`}>{book.category}</p>
      <p className={`text-sm ${textClass} mb-4 line-clamp-2`}>{book.description}</p>
      
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-1">
          <Star className="w-5 h-5 text-yellow-500 fill-yellow-500" />
          <span className={`font-semibold ${textClass}`}>{avgRating}</span>
          <span className={`text-sm ${textSecondary}`}>({book.reviews?.length || 0})</span>
        </div>
        <span className={`text-sm ${textSecondary}`}>{book.page_count} pages</span>
      </div>
    </div>
  );
};

export default BookCard;

### client/src/components/BookDetailView.jsx
import React, { useState, useEffect } from "react";
import { Star } from 'lucide-react';
import api from '../services/api';
import LoadingSpinner from "./LoadingSpinner";

const BookDetailView = ({ bookId, onBack, settings, showToast }) => {
  const [book, setBook] = useState(null);
  const [loading, setLoading] = useState(true);
  const [reviewData, setReviewData] = useState({ rating: 5, comment: '' });

  const cardClass = settings.darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = settings.darkMode ? 'text-white' : 'text-gray-900';
  const textSecondary = settings.darkMode ? 'text-gray-400' : 'text-gray-600';

  useEffect(() => {
    fetchBook();
  }, [bookId]);

  const fetchBook = async () => {
    try {
      const response = await api.get(`/book/${bookId}`);
      setBook(response.data);
    } catch (error) {
      const errorMsg = error.response?.data?.detail?.message || 
                       error.response?.data?.detail || 
                       error.message;
      showToast(errorMsg, 'error');
      onBack();
    } finally {
      setLoading(false);
    }
  };

  const handleAddReview = async (e) => {
    e.preventDefault();
    try {
      await api.post(`/reviews/add_review/${bookId}`, {
        rating: parseInt(reviewData.rating),
        comment: reviewData.comment,
      });
      showToast('Review added successfully!', 'success');
      setReviewData({ rating: 5, comment: '' });
      fetchBook();
    } catch (error) {
      const errorMsg = error.response?.data?.detail?.message || 
                       error.response?.data?.detail || 
                       error.message;
      showToast(errorMsg, 'error');
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <LoadingSpinner darkMode={settings.darkMode} />
      </div>
    );
  }

  if (!book) return null;

  const avgRating = book.reviews?.length > 0
    ? (book.reviews.reduce((sum, r) => sum + r.rating, 0) / book.reviews.length).toFixed(1)
    : 'N/A';

  return (
    <div className="space-y-6">
      <button
        onClick={onBack}
        className={`px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'} hover:opacity-80`}
      >
        â† Back
      </button>

      <div className={`${cardClass} rounded-xl shadow-lg p-8`}>
        <h1 className={`text-4xl font-bold ${textClass} mb-4`}>{book.title}</h1>
        <p className={`text-xl ${textSecondary} mb-2`}>by {book.author}</p>
        <p className={`${textSecondary} mb-4`}>{book.publisher} â€¢ {book.language}</p>
        
        <div className="flex items-center gap-4 mb-6 flex-wrap">
          <div className="flex items-center gap-1">
            <Star className="w-6 h-6 text-yellow-500 fill-yellow-500" />
            <span className={`text-2xl font-semibold ${textClass}`}>{avgRating}</span>
            <span className={textSecondary}>({book.reviews?.length || 0} reviews)</span>
          </div>
          <span className={textSecondary}>{book.page_count} pages</span>
          <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm">{book.category}</span>
        </div>

        <p className={`${textClass} leading-relaxed`}>{book.description}</p>
      </div>

      <div className={`${cardClass} rounded-xl shadow-lg p-8`}>
        <h2 className={`text-2xl font-bold ${textClass} mb-4`}>Add a Review</h2>
        <form onSubmit={handleAddReview} className="space-y-4">
          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Rating</label>
            <select
              value={reviewData.rating}
              onChange={(e) => setReviewData({ ...reviewData, rating: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
            >
              {[1, 2, 3, 4, 5].map(num => (
                <option key={num} value={num}>{num} Star{num > 1 ? 's' : ''}</option>
              ))}
            </select>
          </div>

          <div>
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Comment</label>
            <textarea
              required
              maxLength={80}
              value={reviewData.comment}
              onChange={(e) => setReviewData({ ...reviewData, comment: e.target.value })}
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border border-gray-300 focus:ring-2 focus:ring-blue-500 outline-none`}
              rows="3"
              placeholder="Share your thoughts..."
            />
            <p className={`text-sm ${textSecondary} mt-1`}>{reviewData.comment.length}/80 characters</p>
          </div>

          <button
            type="submit"
            className="w-full bg-blue-500 text-white py-2 rounded-lg font-semibold hover:bg-blue-600 transition"
          >
            Submit Review
          </button>
        </form>
      </div>

      <div className={`${cardClass} rounded-xl shadow-lg p-8`}>
        <h2 className={`text-2xl font-bold ${textClass} mb-6`}>Reviews</h2>
        {book.reviews?.length === 0 ? (
          <p className={textSecondary}>No reviews yet. Be the first to review!</p>
        ) : (
          <div className="space-y-4">
            {book.reviews?.map((review) => (
              <div key={review.id} className={`border-b ${settings.darkMode ? 'border-gray-700' : 'border-gray-200'} pb-4 last:border-0`}>
                <div className="flex items-center gap-2 mb-2">
                  <div className="flex">
                    {[...Array(5)].map((_, i) => (
                      <Star
                        key={i}
                        className={`w-4 h-4 ${i < review.rating ? 'text-yellow-500 fill-yellow-500' : 'text-gray-300'}`}
                      />
                    ))}
                  </div>
                  <span className={`text-sm ${textSecondary}`}>
                    {new Date(review.created_at).toLocaleDateString()}
                  </span>
                </div>
                <p className={textClass}>{review.comment}</p>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default BookDetailView;

### client/src/components/Dashboard.jsx
// src/components/Dashboard.jsx
import React, { useState, useEffect } from 'react';
import { 
  Book, 
  User, 
  Home, 
  PlusCircle, 
  LogOut, 
  Menu, 
  X, 
  Sun, 
  Moon, 
  Search 
} from 'lucide-react';


import ProfilePage from './ProfilePage';
import Logo from './Logo';


import { useAuth } from '../context/AuthContext';
import api from '../services/api';
import BookCard from './BookCard';
import BookDetailView from './BookDetailView';
import AddBookForm from './AddBookForm';
import LoadingSpinner from './LoadingSpinner';
import useToast from '../hooks/useToast';

const Dashboard = () => {
  const { user, logout } = useAuth();
  const [currentView, setCurrentView] = useState('home');
  const [books, setBooks] = useState([]);
  const [myBooks, setMyBooks] = useState([]);
  const [loading, setLoading] = useState(true);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [showAddBook, setShowAddBook] = useState(false);
  const [selectedBookId, setSelectedBookId] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [settings, setSettings] = useState({
    darkMode: localStorage.getItem('darkMode') === 'true',
    fontFamily: 'system-ui, -apple-system, sans-serif',
  });

  const { showToast, ToastContainer } = useToast();

  const bgClass = settings.darkMode ? 'bg-gray-900' : 'bg-gray-50';
  const cardClass = settings.darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = settings.darkMode ? 'text-white' : 'text-gray-900';
  const borderClass = settings.darkMode ? 'border-gray-700' : 'border-gray-200';

  // Save settings to localStorage
  useEffect(() => {
    localStorage.setItem('darkMode', settings.darkMode);
  }, [settings.darkMode]);

  useEffect(() => {
    loadBooks();
    if (user?.user_id) {
      loadMyBooks();
    }
  }, [user]);

 const loadBooks = async () => {
  try {
    const response = await api.get('/book/');
    setBooks(response.data);
  } catch (error) {
    // Handle nested error structure
    const errorMsg = error.response?.data?.detail?.message || 
                     error.response?.data?.detail || 
                     error.message;
    showToast(errorMsg, 'error');
  } finally {
    setLoading(false);
  }
};
const loadMyBooks = async () => {
  try {
    const response = await api.get(`/book/user/${user.user_id}`);
    setMyBooks(response.data);
  } catch (error) {
    const errorMsg = error.response?.data?.detail?.message || 
                     error.response?.data?.detail || 
                     error.message;
    showToast(errorMsg, 'error');
  }
};


const handleAddBook = async (formData) => {
  try {
    const publishedDate = formData.published_date
      ? `${formData.published_date}T00:00:00`
      : new Date().toISOString();

    const bookData = {
      ...formData,
      published_date: publishedDate,
      page_count: parseInt(formData.page_count),
    };

    await api.post('/book/create_book', bookData);
    showToast('Book added successfully!', 'success');
    setShowAddBook(false);
    setCurrentView('my-books');
    loadBooks();
    loadMyBooks();
  } catch (error) {
    const errorMsg = error.response?.data?.detail?.message || 
                     error.response?.data?.detail || 
                     error.userMessage || 
                     error.message;
    showToast(errorMsg, 'error');
  }
};

  const handleLogout = async () => {
    try {
      await api.post('/auth/logout');
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      logout();
      showToast('Logged out successfully', 'success');
    }
  };

  const navItems = [
    { id: 'home', label: 'Home', icon: Home },
    { id: 'books', label: 'All Books', icon: Book },
    { id: 'my-books', label: 'My Books', icon: User },
    { id: 'add-book', label: 'Add Book', icon: PlusCircle },
      { id: 'profile', label: 'Profile', icon: User }, // Add this line

  ];

  const filteredBooks = currentView === 'books' 
    ? books.filter(book => 
        book.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
        book.author.toLowerCase().includes(searchQuery.toLowerCase()) ||
        book.category.toLowerCase().includes(searchQuery.toLowerCase())
      )
    : myBooks.filter(book => 
        book.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
        book.author.toLowerCase().includes(searchQuery.toLowerCase())
      );

  if (loading) {
    return (
      <div className={`min-h-screen ${bgClass} flex items-center justify-center`}>
        <div className="text-center">
          <LoadingSpinner darkMode={settings.darkMode} />
          <p className={`mt-4 ${textClass} text-sm`}>Loading books...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={`min-h-screen ${bgClass} transition-colors`} style={{ fontFamily: settings.fontFamily }}>
      <ToastContainer />
      
      {/* Mobile Header */}
      <div className={`${cardClass} border-b ${borderClass} sticky top-0 z-40 shadow-sm`}>
  <div className="flex items-center justify-between p-4">
    <Logo size="medium" darkMode={settings.darkMode} />
    
    <div className="flex items-center gap-2">
      <button
        onClick={() => setSettings({ ...settings, darkMode: !settings.darkMode })}
        className={`p-2 rounded-lg ${settings.darkMode ? 'bg-gray-700' : 'bg-gray-100'} hover:opacity-80 transition-opacity`}
      >
        {settings.darkMode ? 
          <Sun className="w-5 h-5 text-yellow-400" /> : 
          <Moon className="w-5 h-5 text-gray-600" />
        }
      </button>
      
      <button
        onClick={() => setSidebarOpen(!sidebarOpen)}
        className={`p-2 rounded-lg ${settings.darkMode ? 'bg-gray-700' : 'bg-gray-100'} hover:opacity-80 transition-opacity lg:hidden`}
      >
        <Menu className={`w-5 h-5 ${textClass}`} />
      </button>
    </div>
  </div>

        {/* Desktop Navigation */}
        <div className="hidden lg:flex items-center gap-2 px-4 pb-4 flex-wrap">
          {navItems.map(({ id, label, icon: Icon }) => (
            <button
              key={id}
              onClick={() => {
                setCurrentView(id);
                setSelectedBookId(null);
                setShowAddBook(false);
                setSearchQuery('');
              }}
              className={`px-4 py-2 rounded-lg flex items-center gap-2 transition-colors ${
                currentView === id 
                  ? 'bg-blue-500 text-white' 
                  : `${settings.darkMode ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`
              }`}
            >
              <Icon className="w-4 h-4" />
              {label}
            </button>
          ))}
          <button
            onClick={handleLogout}
            className={`ml-auto px-4 py-2 rounded-lg flex items-center gap-2 ${settings.darkMode ? 'bg-red-900 text-red-200 hover:bg-red-800' : 'bg-red-500 text-white hover:bg-red-600'} transition-colors`}
          >
            <LogOut className="w-4 h-4" />
            Logout
          </button>
        </div>
      </div>

      {/* Sidebar Overlay for Mobile */}
      {sidebarOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40 lg:hidden"
          onClick={() => setSidebarOpen(false)}
        />
      )}

      {/* Sidebar */}
      <div className={`
        fixed top-0 left-0 h-full w-64 ${cardClass} border-r ${borderClass} z-50 transform transition-transform duration-300 ease-in-out shadow-xl
        ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'}
        lg:hidden
      `}>
        <div className={`p-4 border-b ${borderClass} flex items-center justify-between`}>
          <h2 className={`text-lg font-semibold ${textClass}`}>Menu</h2>
          <button
            onClick={() => setSidebarOpen(false)}
            className={`p-2 rounded-lg ${settings.darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-100'} transition-colors`}
          >
            <X className={`w-5 h-5 ${textClass}`} />
          </button>
        </div>
        
        <nav className="p-4 space-y-2">
          {navItems.map(({ id, label, icon: Icon }) => (
            <button
              key={id}
              onClick={() => {
                setCurrentView(id);
                setSelectedBookId(null);
                setShowAddBook(false);
                setSearchQuery('');
                setSidebarOpen(false);
              }}
              className={`w-full px-4 py-3 rounded-lg flex items-center gap-3 transition-colors ${
                currentView === id 
                  ? 'bg-blue-500 text-white' 
                  : `${settings.darkMode ? 'text-gray-300 hover:bg-gray-700' : 'text-gray-700 hover:bg-gray-100'}`
              }`}
            >
              <Icon className="w-5 h-5" />
              <span className="font-medium">{label}</span>
            </button>
          ))}
          <button
            onClick={() => {
              handleLogout();
              setSidebarOpen(false);
            }}
            className={`w-full px-4 py-3 rounded-lg flex items-center gap-3 ${settings.darkMode ? 'bg-red-900 text-red-200 hover:bg-red-800' : 'bg-red-500 text-white hover:bg-red-600'} transition-colors`}
          >
            <LogOut className="w-5 h-5" />
            <span className="font-medium">Logout</span>
          </button>
        </nav>
      </div>

      {/* Main Content */}
      <div className="max-w-6xl mx-auto p-4">
        {/* Book Detail View */}
        {selectedBookId && (
          <BookDetailView
            bookId={selectedBookId}
            onBack={() => setSelectedBookId(null)}
            settings={settings}
            showToast={showToast}
          />
        )}

        {/* Home View */}
        {!selectedBookId && currentView === 'home' && (
          <div className="space-y-8">
            <div className="text-center py-12">
              <h1 className={`text-5xl font-bold ${textClass} mb-4`}>
                Welcome, {user?.username}!
              </h1>
              <p className={`text-xl ${settings.darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                Manage your book collection with ease
              </p>
            </div>

            <div className="grid md:grid-cols-3 gap-6">
              <button
                onClick={() => setCurrentView('books')}
                className={`${cardClass} rounded-xl shadow-lg p-8 hover:shadow-2xl transition-all transform hover:-translate-y-2`}
              >
                <Book className="w-16 h-16 text-blue-500 mx-auto mb-4" />
                <h3 className={`text-2xl font-bold ${textClass} mb-2`}>All Books</h3>
                <p className={settings.darkMode ? 'text-gray-400' : 'text-gray-600'}>
                  Explore our collection
                </p>
                <div className={`mt-4 text-3xl font-bold text-blue-500`}>{books.length}</div>
              </button>

              <button
                onClick={() => setCurrentView('my-books')}
                className={`${cardClass} rounded-xl shadow-lg p-8 hover:shadow-2xl transition-all transform hover:-translate-y-2`}
              >
                <User className="w-16 h-16 text-purple-500 mx-auto mb-4" />
                <h3 className={`text-2xl font-bold ${textClass} mb-2`}>My Books</h3>
                <p className={settings.darkMode ? 'text-gray-400' : 'text-gray-600'}>
                  Your personal collection
                </p>
                <div className={`mt-4 text-3xl font-bold text-purple-500`}>{myBooks.length}</div>
              </button>

              <button
                onClick={() => setCurrentView('add-book')}
                className={`${cardClass} rounded-xl shadow-lg p-8 hover:shadow-2xl transition-all transform hover:-translate-y-2`}
              >
                <PlusCircle className="w-16 h-16 text-green-500 mx-auto mb-4" />
                <h3 className={`text-2xl font-bold ${textClass} mb-2`}>Add Book</h3>
                <p className={settings.darkMode ? 'text-gray-400' : 'text-gray-600'}>
                  Add to your collection
                </p>
              </button>
            </div>
          </div>
        )}

        {/* All Books View */}
        {!selectedBookId && currentView === 'books' && (
          <div className="space-y-6">
            <div className="flex items-center justify-between flex-wrap gap-4">
              <h1 className={`text-4xl font-bold ${textClass}`}>All Books</h1>
              <div className="relative flex-1 max-w-md">
                <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 ${settings.darkMode ? 'text-gray-400' : 'text-gray-500'}`} />
                <input
                  type="text"
                  placeholder="Search books..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className={`w-full pl-10 pr-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
                />
              </div>
            </div>

            {filteredBooks.length === 0 ? (
              <div className="text-center py-12">
                <p className={settings.darkMode ? 'text-gray-400' : 'text-gray-600'}>
                  {searchQuery ? 'No books found matching your search.' : 'No books available.'}
                </p>
              </div>
            ) : (
              <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredBooks.map((book) => (
                  <BookCard
                    key={book.id}
                    book={book}
                    onClick={() => setSelectedBookId(book.id)}
                    settings={settings}
                  />
                ))}
              </div>
            )}
          </div>
        )}

        {/* My Books View */}
        {!selectedBookId && currentView === 'my-books' && (
          <div className="space-y-6">
            <div className="flex items-center justify-between flex-wrap gap-4">
              <h1 className={`text-4xl font-bold ${textClass}`}>My Books</h1>
              <div className="relative flex-1 max-w-md">
                <Search className={`absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 ${settings.darkMode ? 'text-gray-400' : 'text-gray-500'}`} />
                <input
                  type="text"
                  placeholder="Search your books..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className={`w-full pl-10 pr-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
                />
              </div>
            </div>

            {myBooks.length === 0 ? (
              <div className="text-center py-12">
                <p className={`${settings.darkMode ? 'text-gray-400' : 'text-gray-600'} mb-4`}>
                  You haven't added any books yet.
                </p>
                <button
                  onClick={() => setCurrentView('add-book')}
                  className="text-blue-500 hover:text-blue-600 font-semibold"
                >
                  Add your first book â†’
                </button>
              </div>
            ) : filteredBooks.length === 0 ? (
              <div className="text-center py-12">
                <p className={settings.darkMode ? 'text-gray-400' : 'text-gray-600'}>
                  No books found matching your search.
                </p>
              </div>
            ) : (
              <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredBooks.map((book) => (
                  <BookCard
                    key={book.id}
                    book={book}
                    onClick={() => setSelectedBookId(book.id)}
                    settings={settings}
                  />
                ))}
              </div>
            )}
          </div>
        )}
{!selectedBookId && currentView === 'profile' && (
  <ProfilePage
    settings={settings}
    user={user}
    onBack={() => setCurrentView('home')}
  />
)}
        {/* Add Book View */}
        {!selectedBookId && currentView === 'add-book' && (
          <div className="space-y-6">
            <h1 className={`text-4xl font-bold ${textClass} mb-8`}>Add New Book</h1>
            <AddBookForm
              onAdd={handleAddBook}
              onCancel={() => setCurrentView('home')}
              settings={settings}
            />
          </div>
        )}
      </div>
    </div>
  );
};

export default Dashboard;

### client/src/components/Header.jsx
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import { Book, User, LogOut, Home, PlusCircle, Menu, X } from 'lucide-react';
import { useAuth } from '../context/AuthContext';

const Header = () => {
  const { logout } = useAuth();
  const navigate = useNavigate();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  const handleLogout = async () => {
    await logout();
    navigate('/login');
    toast.success('Logged out successfully');
  };

  return (
    <header className="bg-gradient-to-r from-blue-600 to-purple-600 text-white shadow-lg">
      <div className="container mx-auto px-4 py-4">
        <div className="flex justify-between items-center">
          <Link to="/" className="flex items-center space-x-2">
            <img src="/logo.svg" alt="Logo" className="h-8 w-8" onError={(e) => e.target.style.display = 'none'} />
            <span className="text-2xl font-bold">Blurz Books</span>
          </Link>

          <nav className="hidden md:flex items-center space-x-6">
            <Link to="/" className="hover:text-blue-200 transition flex items-center gap-2">
              <Home size={18} /> Home
            </Link>
            <Link to="/books" className="hover:text-blue-200 transition flex items-center gap-2">
              <Book size={18} /> Books
            </Link>
            <Link to="/my-books" className="hover:text-blue-200 transition flex items-center gap-2">
              <User size={18} /> My Books
            </Link>
            <Link to="/add-book" className="hover:text-blue-200 transition flex items-center gap-2">
              <PlusCircle size={18} /> Add Book
            </Link>
            <button onClick={handleLogout} className="bg-red-500 hover:bg-red-600 px-4 py-2 rounded-lg transition flex items-center gap-2">
              <LogOut size={18} /> Logout
            </button>
          </nav>

          <button onClick={() => setMobileMenuOpen(!mobileMenuOpen)} className="md:hidden">
            {mobileMenuOpen ? <X size={24} /> : <Menu size={24} />}
          </button>
        </div>

        {mobileMenuOpen && (
          <nav className="md:hidden mt-4 space-y-2">
            <Link to="/" className="block py-2 hover:bg-blue-700 px-2 rounded" onClick={() => setMobileMenuOpen(false)}>Home</Link>
            <Link to="/books" className="block py-2 hover:bg-blue-700 px-2 rounded" onClick={() => setMobileMenuOpen(false)}>Books</Link>
            <Link to="/my-books" className="block py-2 hover:bg-blue-700 px-2 rounded" onClick={() => setMobileMenuOpen(false)}>My Books</Link>
            <Link to="/add-book" className="block py-2 hover:bg-blue-700 px-2 rounded" onClick={() => setMobileMenuOpen(false)}>Add Book</Link>
            <button onClick={() => { handleLogout(); setMobileMenuOpen(false); }} className="w-full text-left py-2 hover:bg-red-700 px-2 rounded">Logout</button>
          </nav>
        )}
      </div>
    </header>
  );
};
export default Header;

### client/src/components/LoadingSpinner.jsx
import React from 'react';

const LoadingSpinner = ({ darkMode }) => (
  <div className="inline-block w-10 h-10 border-[2.5px] border-gray-200 border-t-blue-500 rounded-full animate-spin" 
       style={{animationDuration: '0.5s'}}></div>
);

export default LoadingSpinner;

### client/src/components/Logo.jsx
import React from 'react';

const Logo = ({ size = 'medium', darkMode = false, showText = true }) => {
  const sizes = {
    small: { icon: 'w-6 h-6', text: 'text-lg' },
    medium: { icon: 'w-8 h-8', text: 'text-xl' },
    large: { icon: 'w-12 h-12', text: 'text-3xl' },
  };

  const iconSize = sizes[size].icon;
  const textSize = sizes[size].text;
  const textColor = darkMode ? 'text-white' : 'text-gray-900';

  return (
    <div className="flex items-center gap-2">
      <img 
        src="/android-chrome-512x512.png" 
        alt="Blurz Books Logo" 
        className={`${iconSize} object-contain`}
      />
      {showText && (
        <h1 className={`${textSize} font-bold ${textColor}`}>
          Blurz Books
        </h1>
      )}
    </div>
  );
};

export default Logo;

### client/src/components/ProfilePage.jsx
import React, { useState } from 'react';
import { User, Mail, Calendar, BookOpen, Edit2, Save, X } from 'lucide-react';

const ProfilePage = ({ settings, user, onBack }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState({
    username: user?.username || '',
    first_name: user?.first_name || '',
    last_name: user?.last_name || '',
    email: user?.email || '',
  });

  const cardClass = settings.darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = settings.darkMode ? 'text-white' : 'text-gray-900';
  const textSecondary = settings.darkMode ? 'text-gray-400' : 'text-gray-600';
  const borderClass = settings.darkMode ? 'border-gray-700' : 'border-gray-200';

  const handleSave = () => {
    // TODO: Add API call to update user profile
    setIsEditing(false);
  };

  const handleCancel = () => {
    setFormData({
      username: user?.username || '',
      first_name: user?.first_name || '',
      last_name: user?.last_name || '',
      email: user?.email || '',
    });
    setIsEditing(false);
  };

  return (
    <div className="space-y-6 max-w-4xl mx-auto">
      <button
        onClick={onBack}
        className={`px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'} hover:opacity-80`}
      >
        â† Back to Dashboard
      </button>

      {/* Profile Header */}
      <div className={`${cardClass} rounded-xl shadow-lg p-8`}>
        <div className="flex items-start justify-between mb-6">
          <div className="flex items-center gap-4">
            <div className={`w-20 h-20 rounded-full ${settings.darkMode ? 'bg-gray-700' : 'bg-gray-200'} flex items-center justify-center`}>
              <User className={`w-10 h-10 ${textSecondary}`} />
            </div>
            <div>
              <h1 className={`text-3xl font-bold ${textClass}`}>
                {user?.username}
              </h1>
              <p className={textSecondary}>{user?.email}</p>
            </div>
          </div>

          {!isEditing ? (
            <button
              onClick={() => setIsEditing(true)}
              className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition flex items-center gap-2"
            >
              <Edit2 className="w-4 h-4" />
              Edit Profile
            </button>
          ) : (
            <div className="flex gap-2">
              <button
                onClick={handleSave}
                className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition flex items-center gap-2"
              >
                <Save className="w-4 h-4" />
                Save
              </button>
              <button
                onClick={handleCancel}
                className={`px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'} hover:opacity-80 flex items-center gap-2`}
              >
                <X className="w-4 h-4" />
                Cancel
              </button>
            </div>
          )}
        </div>

        {/* Profile Details */}
        <div className={`border-t ${borderClass} pt-6 space-y-4`}>
          <div className="grid md:grid-cols-2 gap-4">
            <div>
              <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
                Username
              </label>
              {isEditing ? (
                <input
                  type="text"
                  value={formData.username}
                  onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                  className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
                />
              ) : (
                <p className={`${textClass} text-lg`}>{user?.username}</p>
              )}
            </div>

            <div>
              <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
                Email
              </label>
              <p className={`${textClass} text-lg flex items-center gap-2`}>
                <Mail className="w-4 h-4" />
                {user?.email}
              </p>
            </div>

            <div>
              <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
                First Name
              </label>
              {isEditing ? (
                <input
                  type="text"
                  value={formData.first_name}
                  onChange={(e) => setFormData({ ...formData, first_name: e.target.value })}
                  className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
                />
              ) : (
                <p className={`${textClass} text-lg`}>{user?.first_name || 'Not set'}</p>
              )}
            </div>

            <div>
              <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
                Last Name
              </label>
              {isEditing ? (
                <input
                  type="text"
                  value={formData.last_name}
                  onChange={(e) => setFormData({ ...formData, last_name: e.target.value })}
                  className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
                />
              ) : (
                <p className={`${textClass} text-lg`}>{user?.last_name || 'Not set'}</p>
              )}
            </div>
          </div>

          <div className="grid md:grid-cols-2 gap-4 pt-4">
            <div className="flex items-center gap-2">
              <Calendar className={`w-5 h-5 ${textSecondary}`} />
              <div>
                <p className={`text-sm ${textSecondary}`}>Member Since</p>
                <p className={textClass}>
                  {user?.created_at ? new Date(user.created_at).toLocaleDateString() : 'Unknown'}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <BookOpen className={`w-5 h-5 ${textSecondary}`} />
              <div>
                <p className={`text-sm ${textSecondary}`}>Account Role</p>
                <p className={textClass}>{user?.role || 'User'}</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Account Statistics */}
      <div className="grid md:grid-cols-3 gap-6">
        <div className={`${cardClass} rounded-xl shadow-lg p-6`}>
          <div className="flex items-center gap-4">
            <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center">
              <BookOpen className="w-6 h-6 text-blue-600" />
            </div>
            <div>
              <p className={textSecondary}>Books Added</p>
              <p className={`text-2xl font-bold ${textClass}`}>0</p>
            </div>
          </div>
        </div>

        <div className={`${cardClass} rounded-xl shadow-lg p-6`}>
          <div className="flex items-center gap-4">
            <div className="w-12 h-12 rounded-full bg-purple-100 flex items-center justify-center">
              <Edit2 className="w-6 h-6 text-purple-600" />
            </div>
            <div>
              <p className={textSecondary}>Reviews Written</p>
              <p className={`text-2xl font-bold ${textClass}`}>0</p>
            </div>
          </div>
        </div>

        <div className={`${cardClass} rounded-xl shadow-lg p-6`}>
          <div className="flex items-center gap-4">
            <div className="w-12 h-12 rounded-full bg-green-100 flex items-center justify-center">
              <User className="w-6 h-6 text-green-600" />
            </div>
            <div>
              <p className={textSecondary}>Account Status</p>
              <p className={`text-2xl font-bold ${textClass}`}>
                {user?.is_verifed ? 'Verified' : 'Pending'}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Change Password Section */}
      <div className={`${cardClass} rounded-xl shadow-lg p-8`}>
        <h2 className={`text-2xl font-bold ${textClass} mb-4`}>Change Password</h2>
        <div className="space-y-4">
          <div>
            <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
              Current Password
            </label>
            <input
              type="password"
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
          <div>
            <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
              New Password
            </label>
            <input
              type="password"
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
          <div>
            <label className={`block text-sm font-medium ${textSecondary} mb-2`}>
              Confirm New Password
            </label>
            <input
              type="password"
              className={`w-full px-4 py-2 rounded-lg ${settings.darkMode ? 'bg-gray-700 text-white' : 'bg-gray-50 text-gray-900'} border ${borderClass} focus:ring-2 focus:ring-blue-500 outline-none`}
            />
          </div>
          <button className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
            Update Password
          </button>
        </div>
      </div>
    </div>
  );
};

export default ProfilePage;

### client/src/components/ProtectedRoute.jsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const ProtectedRoute = ({ children }) => {
  const { user, loading } = useAuth();
  
  if (loading) {
    return <div className="flex items-center justify-center h-screen">Loading...</div>;
  }
  
  return user ? children : <Navigate to="/login" />;
};

export default ProtectedRoute;

### client/src/components/UploadEbookForm.jsx
import React, { useState } from 'react';
import api from '../services/api';

const UploadEbookForm = ({ bookId, onSuccess, settings }) => {
    const [file, setFile] = useState(null);
    const [uploading, setUploading] = useState(false);
    const [error, setError] = useState('');

    const handleFileChange = (e) => {
        const selectedFile = e.target.files[0];

        if (!selectedFile) return;

        // Client-side validation
        const allowedTypes = ['application/pdf', 'application/epub+zip'];
        const maxSize = 50 * 1024 * 1024; // 50MB

        if (!allowedTypes.includes(selectedFile.type) && !selectedFile.name.match(/\.(pdf|epub|mobi)$/i)) {
            setError('Only PDF, EPUB, and MOBI files are allowed');
            return;
        }

        if (selectedFile.size > maxSize) {
            setError('File is too large (max 50MB)');
            return;
        }

        setError('');
        setFile(selectedFile);
    };

    const handleUpload = async () => {
        if (!file) return;

        setUploading(true);
        setError('');

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await api.post(`/book/upload_ebook/${bookId}`, formData, {
                headers: {
                    'Content-Type': 'multipart/form-data',
                },
            });

            if (onSuccess) {
                onSuccess(response.data);
            }
            setFile(null);
        } catch (err) {
            setError(err.response?.data?.detail || 'Upload failed');
        } finally {
            setUploading(false);
        }
    };

    const cardClass = settings?.darkMode ? 'bg-gray-800' : 'bg-white';
    const textClass = settings?.darkMode ? 'text-white' : 'text-gray-900';

    return (
        <div className={`${cardClass} rounded-xl shadow-lg p-6`}>
            <h3 className={`text-xl font-bold ${textClass} mb-4`}>Upload Ebook File</h3>

            {error && (
                <div className="mb-4 p-3 bg-red-500 bg-opacity-10 border border-red-500 rounded-lg">
                    <p className="text-red-500 text-sm">{error}</p>
                </div>
            )}

            <input
                type="file"
                accept=".pdf,.epub,.mobi"
                onChange={handleFileChange}
                className="mb-4 w-full"
                disabled={uploading}
            />

            {file && (
                <div className={`mb-4 ${textClass}`}>
                    <p>Selected: {file.name}</p>
                    <p className="text-sm opacity-70">{(file.size / 1024 / 1024).toFixed(2)} MB</p>
                </div>
            )}

            <button
                onClick={handleUpload}
                disabled={!file || uploading}
                className="w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
            >
                {uploading ? 'Uploading...' : 'Upload Ebook'}
            </button>
        </div>
    );
};

export default UploadEbookForm;
