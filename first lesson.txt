from sqlmodel.ext.asyncio.session import AsyncSession
from .schema import create_book,update_book,book
from sqlmodel import select,desc
from models.book import Book
class BOokService:
    
    
    async def get_books(self,session:AsyncSession):
        statment = select(Book).order_by(desc(Book.created_at))
        result =await session.exec(statment)
        
        return result.all()
    


    async def get_book(self, book_id: str, session: AsyncSession):
        try:
            statement = select(Book).where(Book.id == book_id)
            result = await session.exec(statement)
            book = result.first()
            
            if not book:
                # Nothing found
                raise ValueError(f"Book with ID {book_id} not found")
            
            return book

        except Exception as e:
            print(f"Error retrieving book: {e}")
            return None
    
    
    async def create_book(self,book_data:create_book,session:AsyncSession):
        book_data_dict = book_data.model_dump()
        new_book = Book(
            **book_data_dict
        )
        
        
        session.add(new_book)
        await session.commit()
        return new_book
    
    async def update_book(self, book_id: str, book_data: update_book, session: AsyncSession):
        try:
            get_the_book = await self.get_book(book_id, session)

            if get_the_book is not None:
                book_data_dict = book_data.model_dump(exclude_unset=True)

                for key, value in book_data_dict.items():
                    setattr(get_the_book, key, value)

                await session.commit()
                await session.refresh(get_the_book)
                return get_the_book
            else:
                return None

        except Exception as e:
            print(f"There was an error when updating this book: {e}")
            return None


    async def delete_book(self,book_id:book,session:AsyncSession):
        pass   
    